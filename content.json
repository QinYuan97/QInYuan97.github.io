{"meta":{"title":"Yung's blog","subtitle":null,"description":"凡心所向，素履所往 <br> 生如逆旅，一苇以航","author":"Yung","url":"https://qinyuan97.me"},"pages":[{"title":"","date":"2018-11-26T04:22:03.577Z","updated":"2018-11-26T04:21:32.167Z","comments":true,"path":"google441326c7408f454e.html","permalink":"https://qinyuan97.me/google441326c7408f454e.html","excerpt":"","text":"google-site-verification: google441326c7408f454e.html"},{"title":"about","date":"2018-11-25T15:43:34.000Z","updated":"2018-11-26T01:52:32.660Z","comments":false,"path":"about/index.html","permalink":"https://qinyuan97.me/about/index.html","excerpt":"","text":"###凡心所向，素履所往生如逆旅，一苇以航"},{"title":"分类","date":"2018-11-23T04:21:55.000Z","updated":"2018-11-26T02:10:03.990Z","comments":false,"path":"categories/index.html","permalink":"https://qinyuan97.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-23T04:21:19.000Z","updated":"2018-11-26T02:12:28.821Z","comments":false,"path":"tags/index.html","permalink":"https://qinyuan97.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"秋招正式结束后的总结与感想","slug":"life1","date":"2018-12-07T14:41:17.199Z","updated":"2018-12-07T15:43:33.728Z","comments":false,"path":"2018/12/07/life1/","link":"","permalink":"https://qinyuan97.me/2018/12/07/life1/","excerpt":"","text":"迷茫&emsp;&emsp;在大三下学期的那段时间里吧，突然发现自己保研有些悬，去找实习很不顺利，上的课程也感觉有些困难，没心思学。一度陷入了高一时那种失眠的状态，半夜爬起来甚至想从阳台跳下去，怀疑自己白读了十几年书。想搞信安竞赛确保推免，中途放弃了；想冲一下学习成绩，奈何操作系统和Windows安全，实在是没兴趣，也失败了。 准备&emsp;&emsp;于是下定决心找工作，选择了JavaWeb这个方向，在牛客网上做项目、看面经，在leetcode上刷题，甚至还买了久违的实体书。正式的准备应该是从七月开始的吧，中间也有过一些迷茫与懈怠，爸妈的鼓励和上海交大这几个字让我支撑了下来。期间回了一趟忠县，面对父母和亲朋好友的期待，也坚定了我的信心和勇气。 秋招&emsp;&emsp;回校之前那晚投了很多简历，第一次笔试时招行行用卡中心，第一次面试是在依图科技，感谢当时两个学长面试官的包容和优待，也是提升我的信心。也有一些面试体验不是很好，但也是帮助了我成长吧。&emsp;&emsp;在去小红书面试的路上，看见一对白发苍苍的夫妇，我想着会不会好人有好报，给他们让了座，他们慈祥的笑容和满怀的谢意让我真的庆幸做了这件事。也许是上天看见了吧，小红书的4轮面试都很简单，顺利通过。心中的巨石也算是落了地，不用担心失业了，准备着过一个舒适的中秋假期。&emsp;&emsp;中秋假期那三天，拿到了oppo的sp offer，15k 30w 着实让我激动了很久。从那以后也就开始放松了，放弃了很多机会。直到拼多多来学校宣讲，CTO的忽悠能力和高薪让我又豪情万丈，投简历、刷题、刷面经。两轮面试发挥的不好，本以为没戏了，都给爸妈说安心去成都了，也算是为秋招做一个完整的结尾，第一次和最后的面试都在金虹桥。没想hr突然打电话来hr面，最后给出了23k，40w+的offer，拼多多也在高速发展，实在没有拒绝的理由。 感想&emsp;&emsp;半年以前，永远不会相信自己能拿到这种数字的offer，也是一直给爸妈吹牛逼的40w，现在却实现了。选择真的和努力同样重要啊！如果当时选择了考研、或者选择了python、或者选择暑假去一个破地方实习，更久远一点，如果当时没选这个计算机相关的专业甚至没选择交大，现在不知会是怎样的情景和心情。缘分也是存在的吧，如果华为实习面试时没表现得那么傻比，可能就去华为实习然后白菜价转正了，如果拼多多宣讲时没有多问一句，就错过了。&emsp;&emsp;期间也发生了一些事，比如陈老师的意外。陈老师是我的伯乐，没有他也应该不会有我高考的成绩，这件事让我体会到了生命的脆弱和珍贵，珍惜身体的人！也希望他能好转起来。&emsp;&emsp;总而言之，一分耕耘，一分收获，加之正确的目标，成功并不遥远。从今天开始，我也在为工作做准备了，巩固并拓展专业知识，改善自己不擅长的方面（比如人际交往、沟通、ppt）。世俗的成功，我一定会达到的，然后再去探索人生的意义！","categories":[{"name":"life","slug":"life","permalink":"https://qinyuan97.me/categories/life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://qinyuan97.me/tags/随笔/"}]},{"title":"Object类的通用方法","slug":"effectiveJava3","date":"2018-12-07T13:57:33.503Z","updated":"2018-12-07T13:58:52.746Z","comments":true,"path":"2018/12/07/effectiveJava3/","link":"","permalink":"https://qinyuan97.me/2018/12/07/effectiveJava3/","excerpt":"Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。","text":"Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。 7. 改写 equals 时的约定&emsp;&emsp;不改写equals的情况下，每个实例只与它自己相等，这种情况满足下列任何一个条件： 一个类的每一个实例本质上是唯一的代表了活动实体而不是值（value）的类，如 Thread。 不关心一个类是否提供“逻辑相等”的测试功能 超类已经改写了equals 一个类是私有的，或包级私有的，并且可以确定它的 equals 方法永远也不会调用。这种情形下，应该要改写equals方法，以免万一有一天它会被调用到：123public boolean equals(Object o)&#123; throw new UnsupportedOperationException();&#125; &emsp;&emsp;改写 equals 的约定： 自反性—— 一个对象等于其自身 对称从—— a.equals(b) 和 b.equals(a) 必须返回同样的结果 传递性—— a等于b，b等于c，则a等于c1234567891011121314public class ColorPoint extends Point&#123; private Color color; ... public boolean equals(Object o)&#123; if(!(o instanceof Point)) return false; //如果o是无色点，做忽略颜色的比较 if(!(o instanceof ColorPoint)) return o.equals(this); ColorPoint cp = (ColorPoint)o; return super.equals(o) &amp;&amp; cp.color = this.color; &#125;&#125; 这种方法提供了对称性，但牺牲了传递性，比如：123456789101112ColorPoint p1 = new ColorPoint(1, 1, blue);Point p2 = new Point(1,1);ColorPoint p3 = new ColorPoint(1, 1, red);``` 解决：（复合优于继承，tips14），不让 ColorPoint 继承 Point，而是在 ColorPoint 中加入一个私有的 Point 域```Javapublic class ColorPoint&#123; private Point point; private Color color; ...&#125; 一致性—— 如果两个对象相等，除非发生修改，否则必须始终保持相等 非空性—— 所有的对象都必须不等于 null 8. 改写 equals 时必须改写hashCode在每个改写了 equals 方法的类中，必须改写 hashCode 方法，使该类能与基于散列值(hash)的集合类一起正常运作。hashCode的预定： 如果一个对象的 equals 方法做比较所用到的信息没有被修改，那么调用 hashCode 方法必须返回同一整数 两个对象根据 equals 方法是相等的，那么hashCode方法产生同样的整数结果 不同对象的hashCode可以相同 一个好的hash函数 令int result = 17 或任意非零常数 对于对象每一个关键域 f（equals中用到的），完成以下步骤： a. 为该域计算int类型的的散列码c:&amp;emsp;&amp;emsp;i. boolean类型，c = f ? 0 : 1 &amp;emsp;&amp;emsp;ii. byte、short、char、int，c = (int)f &amp;emsp;&amp;emsp;iii. long类型，c = (int)(f ^ (f &gt;&gt;&gt; 32)) &amp;emsp;&amp;emsp;iv. float类型，c = Float.floatToIntBits(f) &amp;emsp;&amp;emsp;v. doubel类型，则先Double.doubleToLongBits(f)得到一个long类型的值 &amp;emsp;&amp;emsp;vi. 该域是一个对象引用，则递归调用 hashCode，如为null，则返回0 &amp;emsp;&amp;emsp;vii. 该域是一个数组，则把每一个元素当成单独的域处理 b. result = 37*result + c 返回result 测试 关键点 可以把冗余域排除在外 2.b中的乘法部分使得散列值依赖于域的顺序，这是合理的。例如不同字符排列的字符串是不同的。 缓存 hashCode1private volatile int hashCode = 0; 9. 总是要改写toString()提供一个好的 toString() 实现，可以使一个类使用起来更加愉快。当一个对象被传递给 println、字符串连接操作符(+)时，会自动调用toString()方法。 10. 谨慎改写 clone()Cloneable具有很多问题，推荐用拷贝构造函数来替代12public Person(Person person);public static Person newInstance(Person person); //静态工厂 &emsp;&emsp;一个拷贝构造函数可以带一个参数，它的类型可以是该类实现的一个适当的接口。例如，所有通用集合都实现了一个拷贝构造函数，它的参数类型时Collection或Map。假如有一个 LinkedList ，则可以 new ArrayList(l) 11. 考虑实现Comparable接口compareTo()方法与equals()方法的约定相似。当该对象小于、等于或大于指定对象时，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法比较，则抛出 ClassCastException 异常。","categories":[{"name":"Java","slug":"Java","permalink":"https://qinyuan97.me/categories/Java/"}],"tags":[{"name":"EffectiveJava","slug":"EffectiveJava","permalink":"https://qinyuan97.me/tags/EffectiveJava/"},{"name":"Object","slug":"Object","permalink":"https://qinyuan97.me/tags/Object/"},{"name":"Note","slug":"Note","permalink":"https://qinyuan97.me/tags/Note/"}]},{"title":"对象的创建和销毁","slug":"effectiveJava2","date":"2018-12-07T08:22:45.251Z","updated":"2018-12-07T13:59:01.764Z","comments":true,"path":"2018/12/07/effectiveJava2/","link":"","permalink":"https://qinyuan97.me/2018/12/07/effectiveJava2/","excerpt":"&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。","text":"&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。 1. 考虑用静态工厂方法替代构造函数123public static Boolean valueOf(boolean b)&#123; return(b ? Boolean.TRUE : Boolean.FALSE);&#125; 好处 与构造函数不同，静态工厂方法拥有名字，可以使一个类更易与使用，代码更易读 每次被调用时，不要求非得创建一个对象把已经构造好的实例缓存起来，避免频繁创建相同的对象 可以返回一个原返回类型子类的对象 缺点 如果类不含有公有的或受保护的构造函数，就不能被子类化 与其他的静态方法没有任何区别在API文档中，不会像构造函数那样被明显标示出来。静态工作方法应遵守标准的命名规范，如 getInstance 2. 使用私有构造函数强化singleton属性&emsp;&emsp;singleton通常被用来指代那些本质上具有唯一性的系统组件，比如系统显示或文件系统。&emsp;&emsp;实现单例有两种方法，都要把构造函数保持为私有的，并且提供一个静态成员，以便允许客户能访问到该类唯一的实例。 1234567public class Singleton&#123; public static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125;&#125; 第二种提供了一个公有的静态方法，而不是公有的静态final域。1234567891011public class Singleton&#123; private static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125; public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125; 当序列化遇到单例时,就会出现问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求一个JVM中只有一个类对象的, 而现在通过反序列化,一个新的对象克隆了出来。加入readResolve方法：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE&#125; 尽管构造函数是私有的，但可序列化工具具有创建类实例的特殊访问权限—— 被实例化的类上的私有方法，称为readResolve（）。 3. 私有化构造函数使类不能实例化这样的工具类(utility class)不希望被实例化，让其包含单个显式的私有构造函数123456public class utilityClass&#123; private utilityClass&#123; &#125; ...&#125; 4. 避免创建重复的对象反面例子：1String s = new String(\"silly\"); // DOn't DO THIS! 应当：1String s = \"no longer silly\"; 5. 消除过期的对象引用一个可能引起内存泄漏的例子（用数组实现栈）：123456789101112131415161718192021222324252627282930public class Stack&#123; private Object[] elements; private int size = 0; public Stack(int initialCapacity)&#123; this.size = new Object[initialCapacity]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; /** * 确保容量 **/ private void ensureCapacity()&#123; if(elements.length == size)&#123; Object[] oldElements = elements; elements = new Object[2 * size + 1]; System.arraycopy(oldElements, 0, elements, 0, size); &#125; &#125;&#125; 问题：如果一个栈先增长，再弹出，那么弹出的对象不会被当做垃圾回收。 修复：一旦对象引用已经过期，将其置空。pop()方法修改：12345678public Object pop()&#123; if(size == 0)&#123; throw ... &#125; Object result = element[--size]; element[size] = null; return result;&#125; 6. 避免使用终结函数(finalize)如果一个子类改写了终结函数，那么子类的终结函数必须手工调用超类的终结函数:1super.finalize();","categories":[{"name":"Java","slug":"Java","permalink":"https://qinyuan97.me/categories/Java/"}],"tags":[{"name":"EffectiveJava","slug":"EffectiveJava","permalink":"https://qinyuan97.me/tags/EffectiveJava/"},{"name":"Object","slug":"Object","permalink":"https://qinyuan97.me/tags/Object/"},{"name":"Note","slug":"Note","permalink":"https://qinyuan97.me/tags/Note/"}]}]}