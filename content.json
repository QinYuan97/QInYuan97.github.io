{"meta":{"title":"Yung's blog","subtitle":null,"description":"凡心所向，素履所往 <br> 生如逆旅，一苇以航","author":"Yung","url":"https://qinyuan97.me"},"pages":[{"title":"","date":"2018-11-26T04:22:03.577Z","updated":"2018-11-26T04:21:32.167Z","comments":true,"path":"google441326c7408f454e.html","permalink":"https://qinyuan97.me/google441326c7408f454e.html","excerpt":"","text":"google-site-verification: google441326c7408f454e.html"},{"title":"tags","date":"2018-11-23T04:21:19.000Z","updated":"2018-11-26T02:12:28.821Z","comments":false,"path":"tags/index.html","permalink":"https://qinyuan97.me/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-23T04:21:55.000Z","updated":"2018-11-26T02:10:03.990Z","comments":false,"path":"categories/index.html","permalink":"https://qinyuan97.me/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-25T15:43:34.000Z","updated":"2018-11-26T01:52:32.660Z","comments":false,"path":"about/index.html","permalink":"https://qinyuan97.me/about/index.html","excerpt":"","text":"###凡心所向，素履所往生如逆旅，一苇以航"}],"posts":[{"title":"对象的创建和销毁","slug":"effectiveJava2","date":"2018-12-07T08:22:45.251Z","updated":"2018-12-07T08:23:27.725Z","comments":true,"path":"2018/12/07/effectiveJava2/","link":"","permalink":"https://qinyuan97.me/2018/12/07/effectiveJava2/","excerpt":"&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。","text":"&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。 1. 考虑用静态工厂方法替代构造函数123public static Boolean valueOf(boolean b)&#123; return(b ? Boolean.TRUE : Boolean.FALSE);&#125; 好处 与构造函数不同，静态工厂方法拥有名字，可以使一个类更易与使用，代码更易读 每次被调用时，不要求非得创建一个对象把已经构造好的实例缓存起来，避免频繁创建相同的对象 可以返回一个原返回类型子类的对象 缺点 如果类不含有公有的或受保护的构造函数，就不能被子类化 与其他的静态方法没有任何区别在API文档中，不会像构造函数那样被明显标示出来。静态工作方法应遵守标准的命名规范，如 getInstance 2. 使用私有构造函数强化singleton属性&emsp;&emsp;singleton通常被用来指代那些本质上具有唯一性的系统组件，比如系统显示或文件系统。&emsp;&emsp;实现单例有两种方法，都要把构造函数保持为私有的，并且提供一个静态成员，以便允许客户能访问到该类唯一的实例。 1234567public class Singleton&#123; public static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125;&#125; 第二种提供了一个公有的静态方法，而不是公有的静态final域。1234567891011public class Singleton&#123; private static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125; public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125; 当序列化遇到单例时,就会出现问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求一个JVM中只有一个类对象的, 而现在通过反序列化,一个新的对象克隆了出来。加入readResolve方法：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE&#125; 尽管构造函数是私有的，但可序列化工具具有创建类实例的特殊访问权限—— 被实例化的类上的私有方法，称为readResolve（）。 3. 私有化构造函数使类不能实例化这样的工具类(utility class)不希望被实例化，让其包含单个显式的私有构造函数123456public class utilityClass&#123; private utilityClass&#123; &#125; ...&#125; 4. 避免创建重复的对象反面例子：1String s = new String(\"silly\"); // DOn't DO THIS! 应当：1String s = \"no longer silly\"; 5. 消除过期的对象引用一个可能引起内存泄漏的例子（用数组实现栈）：123456789101112131415161718192021222324252627282930public class Stack&#123; private Object[] elements; private int size = 0; public Stack(int initialCapacity)&#123; this.size = new Object[initialCapacity]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; /** * 确保容量 **/ private void ensureCapacity()&#123; if(elements.length == size)&#123; Object[] oldElements = elements; elements = new Object[2 * size + 1]; System.arraycopy(oldElements, 0, elements, 0, size); &#125; &#125;&#125; 问题：如果一个栈先增长，再弹出，那么弹出的对象不会被当做垃圾回收。 修复：一旦对象引用已经过期，将其置空。pop()方法修改：12345678public Object pop()&#123; if(size == 0)&#123; throw ... &#125; Object result = element[--size]; element[size] = null; return result;&#125; 6. 避免使用终结函数(finalize)如果一个子类改写了终结函数，那么子类的终结函数必须手工调用超类的终结函数:1super.finalize();","categories":[{"name":"Java","slug":"Java","permalink":"https://qinyuan97.me/categories/Java/"}],"tags":[{"name":"EffectiveJava","slug":"EffectiveJava","permalink":"https://qinyuan97.me/tags/EffectiveJava/"},{"name":"Object","slug":"Object","permalink":"https://qinyuan97.me/tags/Object/"}]}]}