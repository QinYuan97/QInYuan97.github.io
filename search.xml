<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中的注解]]></title>
    <url>%2F2019%2F06%2F17%2FJava%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[介绍 Java 中注解的原理和一些常用的注解 什么是注解注解是一种元数据，即描述数据的数据，应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。java.lang.annotation 提供四种元注解，专门注解其它的注解： @Documented 是否将注解信息添加在 java 文档中。 @Retention 定义该注解的生命周期 RetentionPolicy.SOURCE —— 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。RetentionPolicy.CLASS —— 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。RetentionPolicy.RUNTIME —— 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。自定义的注解通常使用这种方式。 @Target 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方 ElementType.TYPE: 用于描述类、接口或enum声明ElementType.FIELD: 用于描述实例变量ElementType.METHODElementType.PARAMETERElementType.CONSTRUCTORElementType.LOCAL_VARIABLEElementType.ANNOTATION_TYPE 另一个注释ElementType.PACKAGE 用于记录java文件的package信息 @Inherited 是否允许子类继承该注解 自定义注解注解的内部只支持基本类型、String及枚举类型。注释中所有的属性被定义成方法，并允许提供默认值。123456789@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Todo &#123; public enum Priority &#123;LOW, MEDIUM, HIGH&#125;; public enum Status &#123;STARTED, NOT_STARTED&#125;; String author() default "Yash"; Priority priority() default Priority.LOW; Status status() default Status.NOT_STARTED;&#125; 使用上面的注解：12345@Todo(priority = Todo.Priority.MEDIUM, author = "Yashwant", status = Todo.Status.STARTED)public void incompleteMethod1() &#123;//Some business logic is written//But it’s not complete yet&#125; 如果注解中只有一个属性，可以直接命名为“value”，使用时无需再标明属性名。1234567@interface Author&#123;String value();&#125;@Author("Yashwant")public void someMethod() &#123;&#125; 在用户程序中使用反射机制调用自定义注解：12345678910Class businessLogicClass = BusinessLogic.class;for(Method method : businessLogicClass.getMethods()) &#123; Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class); if(todoAnnotation != null) &#123; System.out.println(" Method Name : " + method.getName()); System.out.println(" Author : " + todoAnnotation.author()); System.out.println(" Priority : " + todoAnnotation.priority()); System.out.println(" Status : " + todoAnnotation.status()); &#125;&#125; Spring 中常用注解 Controller注解一个类表示控制器，Spring MVC会自动扫描标注了这个注解的类。 RequestMapping请求路径映射，可以标注类，也可以是方法，可以指定请求类型，默认不指定为全部接收。 RequestParam放在参数前，用于将URL中的参数绑定到处理函数方法的变量中。 RequestBody放在参数前，表示参数从request body中获取，而不是从 url 获取。 ResponseBody放在方法上前，表示此方法返回的数据放在response body里面，而不是跳转页面。一般用于ajax请求，返回json数据。 PathVariable路径绑定变量，用于绑定restful路径上的变量。 RequestHeader放在方法参数前，用来获取request header中的参数值。 CookieValue放在方法参数前，用来获取request header cookie中的参数值。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Spring</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bitmap算法]]></title>
    <url>%2F2019%2F06%2F17%2Fbitmap%2F</url>
    <content type="text"><![CDATA[在1亿个整数里面快速查找某个整数是否存在其中，使用 bitmap 算法：用一个比特位来表示一个数 假设原有的 bitmap 中存储了4和12这两个数字，则结构为： 存储一个数的过程：12345678910public void set(int number)&#123; //除以8，即所在的byte[]数组的索引 int index = number &gt;&gt; 3; // mod 8，即 byte[index] 的位置 int position = number % 0x07; //或运算，将 byte[index]的第 position 位置为1 byte[index] |= 1 &lt;&lt; position;&#125; 判断一个数是否存在：1234567public boolean contain(int number)&#123; int index = number &gt;&gt; 3; int position = number % 0x07; return (byte[index] &amp; (1 &lt;&lt; position)) != 0;&#125; 布隆过滤器假如一千万个数字，但是数字范围不是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，也就是 120MB 的大小，消耗的内存空间加大了，而且在bitmap里面还会有部分空间浪费的情况存在。 假设我们对每一个数字都进行一次hash计算，然后通过hash将计算后的结果范围限制在1千万里面，那么就不需要再定义10亿个二进制位了。但是这样子还是会有相应的弊端，例如说hash冲突。那么这个时候如果我们采用多个hash函数来进行处理的话，理论上是可以大大降低冲突的概率的。于是就有了下边所说的布隆过滤器一说。 布隆过滤器通过使用多次的hash计算来进行数值是否存在的判断，虽然大大降低了hash冲突的情况，但是还是存在一定的缺陷，那就是会有误判的情况：某个不存在的数字可能会被判断为存在。 java里面提供了BitSet类，Redis也提供了相应的位图类，Google里面的guava工具包中的BloomFilter 也已经实现类布隆过滤器。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高效率的工具和代码]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;记录一些常用的提高效率的工具和代码 常用的类Objects类12345678import java.util.objectspublic static boolean equals(Object a, Object b);public static boolean deepEquals(Object a, Object b);public static boolean toString(Object o, String nullDefault); public static &lt;T&gt; T requireNonNull(T obj, String message); //检查是否为空public static boolean isNull(Object obj); public static boolean nonNull(Object obj); 为什么需要Java8中引入了lambda，因此出现很多 filter(Objects::nonNull) 这样的写法，比filter(x -&gt; x != null) 更直观一些1234List&lt;String&gt; list1 = Arrays.asList("a", "b", null, null);List&lt;String&gt; list2 = list.stream() .filter(Objects::nonNull) .collect(Collectors.toList()); Optional类Optional 类是一个可以为null的容器对象，不用显示进行空值检测，很好的解决了空指针异常1234import java.util.Optional;Optional.ofNullable(request.getWord()).ifPresent(word::setWord);word.setWord(Optional.ofNullable(request.getWord()).orElse("")); 常用的工具Lombok @NonNull: 作用于成员变量和参数 @RequiredArgsConstructor: 生成包含 final 和 @NonNull注解的成员变量的构造器 @NoArgsConstructor: 无参构造器 @AllArgsConstructor: 全参构造器 @Clearup: 自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如典型的IO流对象 1@Cleanup InputStream in = new FileInputStream(file); @SneakyThrows: 对受检异常进行捕捉并抛出 @EqualsAndHashCode: 默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。 @Data: 包含@ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合 @Log: 作用于类，创建一个log属性 常用的代码Java8 StreamStream方式将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等stream of elements -&gt; filter -&gt; sorted -&gt; map -&gt; collect filter设置条件过滤出元素 12//过滤出空字符串int nullCount = strings.stream().filter(Objects::isNull).count(); mapmap方法用于映射每个元素到对应的结果 forEach迭代流中的每个元素 1numList.stream().limit(5).forEach(System.out::println); limit用于获取指定数量的流 sorted对流进行排序 CollectorsCollectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。可用于返回列表或字符串12stream().collect(Collectors.toList());stream().collect(Collectors.joining(",")); 读取文本文件12345678910111213141516171819202122232425262728public class ReadText&#123; public List&lt;String&gt; read(InputStream in)&#123; try&#123; BufferedReader br = new BufferedReader(new InputStreamReader(in)); String line; List&lt;String&gt; result = new ArrayList&lt;&gt;(); while((line = br.readLine()) != null)&#123; result.add(line); &#125; return result; &#125; catch(IOException e)&#123; throw new RuntimeException("error in reading"); &#125; finally&#123; if(in != null)&#123; try&#123; in.close(); &#125; catch(IOException e)&#123; // do nothing &#125; &#125; &#125; &#125; // inputStream 可以两种方式读取 InputStream in = new FileInputStream(new File(filePath)); InputStream in = ReadText.class.getResourceAsStream(fileName); //文件放在 resources目录下，加 /&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>efficiency</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot实战系列]]></title>
    <url>%2F2019%2F02%2F07%2FSpring%20Boot%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[转载自CodeSheep程序羊 数据库/缓存相关 Guava Cache本地缓存在 Spring Boot应用中的实践 EVCache缓存在 Spring Boot中的实战 Spring Boot应用缓存实践之：Ehcache加持 Spring Boot集成 MyBatis和 SQL Server实践 Elasticsearch搜索引擎在Spring Boot中的实践 日志相关 Spring Boot日志框架实践 应用监控相关 利用神器 BTrace 追踪线上 Spring Boot应用运行时信息 Spring Boot应用监控实战 Spring Boot Admin 2.0开箱体验 内部机制相关 SpringBoot 中 @SpringBootApplication注解背后的三体结构探秘 SpringBoot 应用程序启动过程探秘 如何自制一个Spring Boot Starter并推送到远端公服 实战经验相关 Spring Boot工程集成全局唯一ID生成器 UidGenerator Spring Boot 工程集成全局唯一ID生成器 Vesta Spring Boot优雅编码之：Lombok加持 Spring Boot应用 Docker化 Spring Boot热部署加持 基于Spring Boot实现图片上传/加水印一把梭操作 从Spring Boot到 SpringMVC 自然语言处理工具包 HanLP在 Spring Boot中的应用 Spring Boot应用部署于外置Tomcat容器]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的使用]]></title>
    <url>%2F2019%2F01%2F04%2FgitNote%2F</url>
    <content type="text"><![CDATA[git 的基本概念和操作 常用命令 git init在当前目录下初始化 git 仓库 git status查看当前 git 仓库的状态 git add1234git add a.md 将文件提交到缓存区(防止误提交)git add . 把所有变化提交到暂存区，但不包括被删除的文件git add -u 仅监控已被 add 的文件，不会提交新文件git add -A 提交所有 git commit12git commit -m &apos;first commit&apos; git commit -a -m &quot;commit&quot; 跳过add，自动把已跟踪过的文件暂存提交 git log查看所有的 commit 记录 git branch 1234git branch 查看当前分支情况git branch a 在当前分支下新建一个叫 a 的分支，此时内容完全一样git branch -d a 删除分支 agit branch -D a 可能还未合并，强制删除 git checkout123456git checkout a 切换到 a 分支下git checkout -b a 新建并切换到 agit checkout a.md 还原文件，只能撤销还未 add 进缓存区的文件git checkout -b local origin/master 从远程master新建本地仓库git checkout -- file 撤销暂存区中文件的修改 git merge1git merge a 在主分支下把分支 a 的代码合并过来 git diff12git diff 查看工作目录中文件和暂存区的差异git diff --cached 查看已暂存的将要添加到下次提交的内容 git remove 1git rm --cached 从git中删除，但保留在磁盘上 git reset 1git reset HEAD file 取消暂存 git tag 12git tag v1.0 在当前状态下新建一个标签git checkout v1.0 切换到 v.1.0 的代码状态 push &amp; pullpush：本地代码有更新，推到远程仓库1git push origin master &emsp;&emsp;pull：别人提交代码到远程仓库，把远程仓库的最新代码拉下来。一般 push 之前先 pull，不容易冲突1git pull origin master 提交代码1git clone git@...git 将远程项目 clone 到本地1git push origin master 提交代码到远程仓库1git remote add origin git@...git 将本地项目与 github 上的项目关联，origin 是远程仓库的名字12git config —global user.name &quot;qinyuan&quot;git config —global user.email &quot;qinyuan1997@gmail.com&quot; 设置用户名和邮箱（去掉 -global 参数，在某一项目中使用特定的邮箱） stash在暂时不能 commit 的情况下暂存代码1git stash 把当前分支所有没有 commit 的代码都暂存起来，但是看不见任何改动1git stash list 查看暂存区记录1git stash apply 还原暂存的代码123git stash drop 删除暂存区的这次 stash 记录git stash pop 还原并删除 stash 记录git stash clear 删除所有 stash 记录]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用服务器变为集群后的Session问题]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E4%B8%BA%E9%9B%86%E7%BE%A4%E5%90%8E%E7%9A%84Session%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;HTTP 协议本身是无状态的，需要基于 HTTP 协议支持会话状态(Session State)的机制。这样的机制使 Web 服务器从多次单独的 HTTP 请求中看到会话，即知道哪些请求是来自哪些会话的。&emsp;&emsp;具体实现方式：在会话开始时，分配一个唯一的会话标识(SessionId)，通过 Cookie 把这个标识告诉浏览器，以后每次请求的时候，浏览器都会带上这个标识来告诉 Web 服务器请求是属于哪个会话的。在 Web 服务器上，每个会话有独立的存储，保存不同会话的信息。如果遇到禁用 Cookie 的情况，一般就把这个会话标识放到URL的参数。&emsp;&emsp;Session 问题：会话数据是保存在单机上的，要保证每一次请求都落在同一个服务器上。 Session Sticky&emsp;&emsp;让负载均衡器能够根据每次请求的会话标识来进行请求转发。&emsp;&emsp;这个方案非常简单，但有一些问题： 如果一台 Web 服务器崩溃或者重启，这台机器上的会话数据就会丢失。 会话标识是应用层的信息，那么负载均衡器要将用一个会话的请求都保存到同一个 Web 服务器上的话，就需要进行应用层的解析，这个开销比第4层的交换要大。 负载均衡器变为了一个有状态的节点，要将会话保存到具体 Web 服务器的映射。和无状态的节点相比，内存消耗更大，容灾方面更麻烦。 Session Replication&emsp;&emsp;Web 服务器之间增加会话数据的同步，保证不同 Web 服务器之间的 Session 书籍的一致。 同步 Session 数据造成了网络带宽的开销。只要 Session 数据有变化，就需要将数据同步到所有其他机器上，机器数越多，同步带来的网络带宽开销就越大。 每台 Web 服务器都要保存所有的 Session 数据，如果整个集群的 Session 数很多，每天机器用于保存 Session 数据的内存占用严重。 &emsp;&emsp;Session Replication 方案是靠应用容器开完成 Session 的复制，应用本身不用关心这个事情。但是，这个方案不适合集群机器数多的场景。 Session 数据集中存储&emsp;&emsp;把Session数据集中存储起来，然后不同 Web 服务器从同一个地方来获取 Session。&emsp;&emsp;存在的问题： 读写 Session 数据引入了网络操作，存在时延和不稳定性。 如果集中存储 Session 的机器或者集群有问题，就会影响应用。 Cookie Based&emsp;&emsp;把 Session 数据放在 Cookie 中，然后在 Web 服务器上从 Cookie 中生成对应的 Session 数据。好比每次都把自己的碗筷带在身上，这样去哪家饭店吃饭就介意随意选择。 Cookie 长度的限制。 安全性问题 每次 HTTP 请求和响应都带有 Session 数据，对性能有影响。 对于大型网站来说，Session Sticky 和 Session 集中存储是比较好的方案。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用技巧]]></title>
    <url>%2F2018%2F12%2F15%2FIntelliJ%20IDEA%2F</url>
    <content type="text"><![CDATA[常见的 IntelliJ IDEA使用技巧整理 编辑(Edit) Ctrl + X 删除一行 Ctrl + W 扩大选择范围 Ctrl + D 复制一行 Ctrl + Shift + 左右箭头 扩大光标选择范围 Ctrl + Shift + U 转换大小写 Ctrl + Shift + V 调出剪切板 Ctrl + R 在文件中查找并替换 Ctrl + Shift + R 查找并替换 Ctrl + Shift + F 查找 Ctrl + Alt + Shift + J 光标选中所有符合的视图(View) Ctrl + Shift + A Find Action Alt + 首字母 弹出对应选项 Alt + 1 跳转到 Project，之后 Ctrl+Shift+左右箭头 可移动分割线 F4 进入代码 Alt + 0 跳转到 Message Ctrl + Shift + F4 关闭 Alt + 4 跳转到 Run Alt + 6 跳转到 Todo Alt + F12 跳转到终端 Ctrl + Q 显示文档 Ctrl + P 显示方法参数 Ctrl + E 最近文件 Ctrl + Shift + E 最近修改文件导航 Alt + 上下箭头 方法之间跳转 Alt + 左右箭头 编辑区文件之间跳转 Ctrl + Alt + [ 或 ] 项目之间跳转 Ctrl + Shift + Backspace 跳转到上次编辑位置 Ctrl + Alt + 左右箭头 编辑位置跳转 Ctrl + G 跳转到行 Ctrl + N 查找类 Ctrl + Shift + N 查找文件 F2 跳转到下个错误 Shift + F2 上个错误代码(Code) Ctrl + O 查看重写的方法 Ctrl + I 查看实现的方法 Alt + Insert 生成构造方法、toString()等 Ctrl + Alt + T 生成代码块 Ctrl + J 插入 Live Template Alt + Shift + 上下箭头 将代码行上下移动 postfix Alt + Enter 不知道怎么写代码时重构(Refactor) Shift + F6 重命名 Extract运行(Run) Shift + F10/F9 运行/Debug 上次的程序 Alt + Shift + F10/F9 选择运行/Debug 程序 文件 Ctrl + C 光标指向文件时复制文件名 Ctrl + Shift + C 复制完整路径 Ctrl + F4 关闭当前编辑器窗口 Shift + Esc 隐藏当前面板Ctrl + F12 查看文件结构Ctrl + Alt + Shift + U 查看类图Ctrl + H 查看方法调用关系]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和接口]]></title>
    <url>%2F2018%2F12%2F09%2FeffectiveJava4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;类和接口是Java程序设计语言的核心，也是Java语言的基本抽象单元。本章的一些指导原则，可以帮助更好的利用这些语言元素，使设计出来的类和接口更将有用、健壮和灵活。 12. 使类和成员的可访问能力最小化&emsp;&emsp;一个设计良好的模块应当隐藏所有的实现细节，把API与实现清晰的隔离起来。然后，模块之间，只通过API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为封装。&emsp;&emsp;封装可以有效的解除一个系统中各模块之间的耦合关系，使得这些模块可以被独立的开发、测试、优化、使用、理解和修改。 四种访问级别 私有的(private)——只有在该类的内部才能访问 包级私有(default)——声明该成员的包内部的任何类都可以访问这个成员 保护的(protected)——子类和包内可访问 公有的(public)——任何地方都能访问 13. 支持非可变性&emsp;&emsp;一个非可变类是一个简单的类，它的实例不能被修改。每个实例中所包含的信息都必须在该实例被创建时就提供出来，并且在对象的整个生存期内固定不变。比如 String 类、原语类型的包装类、BigInteger、BigDecimal等。&emsp;&emsp;为使一个类成为非可变类，要遵循下面五条规则： 不要提供任何会修改对象的方法（也称为 mutator） 保证没有可被子类改写的方法使这个类称为 final 的 使所有域都是 final 的 使所有域称为私有的 保证对于任何可变组件的互斥访问如果该类具有指向可变对象的域，则必须保证客户不能获得这些指向这些对象的引用。不能用客户提供的对象引用来初始化这样的域 &emsp;&emsp;非可变类的优点： 非可变对象比较简单只有一个状态，即最初被创建时的状态 本质上是线程安全的，不需要同步 非可变对象为其他对象，提供了大量的构件 &emsp;&emsp;非可变类唯一的缺点是，对于每一个不同的值都要求一个单独的对象，创建这样的对象可能会代价很高。 14. 复合优于继承(类继承)&emsp;&emsp;一个子类依赖于其超类中特定功能的实现细节，继承打破了封装性。 &emsp;&emsp;假设我们需要查询 HashSet，看它自被创建以来曾经有多少个元素被加了进来，继承 HashSet 类的方法：1234567891011121314151617181920212223242526public class InstrumentedHashSet extends HashSet&#123; //加入的次数 private int addCount = 0; public InstrumentedHashSet()&#123; &#125; public InstrumentedHashSet(Collection c)&#123; super(c); &#125; public boolean add(Object o)&#123; addCount++; return super.add(o); &#125; public boolean addAll(Collection c)&#123; addCount += c.size(); return super.addAll(); &#125; public int getAddCount()&#123; return addCount; &#125;&#125; &emsp;&emsp;这个类看起来非常合理，实际上是错误的。在 HasgSet 的内部，addAll方法是基于 add 实现的，所以调用一次这个类的 addAll，实际加了两次 addCount。&emsp;&emsp;用 复合 (composition)：12345678910111213141516171819202122public class InstrumentedSet implements Set&#123; private final Set s; private int addCount = 0; public InstrumentedSet(Set s)&#123; this.s = s; &#125; public boolean add(Object o)&#123; addCount++; return s.add(o); &#125; public boolean addAll(Collection c)&#123; addCount += c.size(); return s.addAll(c); &#125; ... // 待实现的方法 ...&#125; &emsp;&emsp;每一个InstrumentedSet实例都把另一个Set实例包装起来了，所以InstrumentedSet被称作包装类，这是装饰者模式。 16. 接口优于抽象类&emsp;&emsp;使用抽象类比使用接口的优势：抽象类的演化(比如增加一个新的方法)比接口的演化容易得多， 18. 嵌套类的使用&emsp;&emsp;嵌套类是指被定义在另一个类内部的类，存在的目的只是为它的外围类服务。 静态成员类最简单地内部类，可以访问外围类的所有成员，包括私有的成员。如果成员类不要求访问外围实例，则声明为静态的。 非静态成员类非静态成员类的每一个实例都与外围类的一个外围实例紧密关联在一起 匿名类匿名类通常只实现其接口中或超类中的方法，不会声明任何新的方法。 局部类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Note</tag>
        <tag>Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招正式结束后的总结与感想]]></title>
    <url>%2F2018%2F12%2F07%2Flife1%2F</url>
    <content type="text"><![CDATA[更多…… 迷茫&emsp;&emsp;在大三下学期的那段时间里吧，突然发现自己保研有些悬，去找实习很不顺利，上的课程也感觉有些困难，没心思学。一度陷入了高一时那种失眠的状态，半夜爬起来甚至想从阳台跳下去，怀疑自己白读了十几年书。想搞信安竞赛确保推免，中途放弃了；想冲一下学习成绩，奈何操作系统和Windows安全，实在是没兴趣，也失败了。 准备&emsp;&emsp;于是下定决心找工作，选择了JavaWeb这个方向，在牛客网上做项目、看面经，在leetcode上刷题，甚至还买了久违的实体书。正式的准备应该是从七月开始的吧，中间也有过一些迷茫与懈怠，爸妈的鼓励和上海交大这几个字让我支撑了下来。期间回了一趟忠县，面对父母和亲朋好友的期待，也坚定了我的信心和勇气。 秋招&emsp;&emsp;回校之前那晚投了很多简历，第一次笔试时招行行用卡中心，第一次面试是在依图科技，感谢当时两个学长面试官的包容和优待，也是提升我的信心。也有一些面试体验不是很好，但也是帮助了我成长吧。&emsp;&emsp;在去小红书面试的路上，看见一对白发苍苍的夫妇，我想着会不会好人有好报，给他们让了座，他们慈祥的笑容和满怀的谢意让我真的庆幸做了这件事。也许是上天看见了吧，小红书的4轮面试都很简单，顺利通过。心中的巨石也算是落了地，不用担心失业了，准备着过一个舒适的中秋假期。&emsp;&emsp;中秋假期那三天，拿到了oppo的sp offer，15k 30w 着实让我激动了很久。从那以后也就开始放松了，放弃了很多机会。直到拼多多来学校宣讲，CTO的忽悠能力和高薪让我又豪情万丈，投简历、刷题、刷面经。两轮面试发挥的不好，本以为没戏了，都给爸妈说安心去成都了，也算是为秋招做一个完整的结尾，第一次和最后的面试都在金虹桥。没想hr突然打电话来hr面，最后给出了23k，40w+的offer，拼多多也在高速发展，实在没有拒绝的理由。 感想&emsp;&emsp;半年以前，永远不会相信自己能拿到这种数字的offer，也是一直给爸妈吹牛逼的40w，现在却实现了。选择真的和努力同样重要啊！如果当时选择了考研、或者选择了python、或者选择暑假去一个破地方实习，更久远一点，如果当时没选这个计算机相关的专业甚至没选择交大，现在不知会是怎样的情景和心情。缘分也是存在的吧，如果华为实习面试时没表现得那么傻比，可能就去华为实习然后白菜价转正了，如果拼多多宣讲时没有多问一句，就错过了。&emsp;&emsp;期间也发生了一些事，比如陈老师的意外。陈老师是我的伯乐，没有他也应该不会有我高考的成绩，这件事让我体会到了生命的脆弱和珍贵，珍惜身体的人！也希望他能好转起来。&emsp;&emsp;总而言之，一分耕耘，一分收获，加之正确的目标，成功并不遥远。从今天开始，我也在为工作做准备了，巩固并拓展专业知识，改善自己不擅长的方面（比如人际交往、沟通、ppt）。世俗的成功，我一定会达到的，然后再去探索人生的意义！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类的通用方法]]></title>
    <url>%2F2018%2F12%2F07%2FeffectiveJava3%2F</url>
    <content type="text"><![CDATA[Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。 7. 改写 equals 时的约定&emsp;&emsp;不改写equals的情况下，每个实例只与它自己相等，这种情况满足下列任何一个条件： 一个类的每一个实例本质上是唯一的代表了活动实体而不是值（value）的类，如 Thread。 不关心一个类是否提供“逻辑相等”的测试功能 超类已经改写了equals 一个类是私有的，或包级私有的，并且可以确定它的 equals 方法永远也不会调用。这种情形下，应该要改写equals方法，以免万一有一天它会被调用到：123public boolean equals(Object o)&#123; throw new UnsupportedOperationException();&#125; &emsp;&emsp;改写 equals 的约定： 自反性—— 一个对象等于其自身 对称从—— a.equals(b) 和 b.equals(a) 必须返回同样的结果 传递性—— a等于b，b等于c，则a等于c1234567891011121314public class ColorPoint extends Point&#123; private Color color; ... public boolean equals(Object o)&#123; if(!(o instanceof Point)) return false; //如果o是无色点，做忽略颜色的比较 if(!(o instanceof ColorPoint)) return o.equals(this); ColorPoint cp = (ColorPoint)o; return super.equals(o) &amp;&amp; cp.color = this.color; &#125;&#125; 这种方法提供了对称性，但牺牲了传递性，比如：123456789101112ColorPoint p1 = new ColorPoint(1, 1, blue);Point p2 = new Point(1,1);ColorPoint p3 = new ColorPoint(1, 1, red);``` 解决：（复合优于继承，tips14），不让 ColorPoint 继承 Point，而是在 ColorPoint 中加入一个私有的 Point 域```Javapublic class ColorPoint&#123; private Point point; private Color color; ...&#125; 一致性—— 如果两个对象相等，除非发生修改，否则必须始终保持相等 非空性—— 所有的对象都必须不等于 null 8. 改写 equals 时必须改写hashCode在每个改写了 equals 方法的类中，必须改写 hashCode 方法，使该类能与基于散列值(hash)的集合类一起正常运作。hashCode的预定： 如果一个对象的 equals 方法做比较所用到的信息没有被修改，那么调用 hashCode 方法必须返回同一整数 两个对象根据 equals 方法是相等的，那么hashCode方法产生同样的整数结果 不同对象的hashCode可以相同 一个好的hash函数 令int result = 17 或任意非零常数 对于对象每一个关键域 f（equals中用到的），完成以下步骤： a. 为该域计算int类型的的散列码c:i. boolean类型，c = f ? 0 : 1 ii. byte、short、char、int，c = (int)f iii. long类型，c = (int)(f ^ (f &gt;&gt;&gt; 32)) iv. float类型，c = Float.floatToIntBits(f) v. doubel类型，则先Double.doubleToLongBits(f)得到一个long类型的值 vi. 该域是一个对象引用，则递归调用 hashCode，如为null，则返回0 vii. 该域是一个数组，则把每一个元素当成单独的域处理 b. result = 37*result + c 返回result 测试 关键点 可以把冗余域排除在外 2.b中的乘法部分使得散列值依赖于域的顺序，这是合理的。例如不同字符排列的字符串是不同的。 缓存 hashCode1private volatile int hashCode = 0; 9. 总是要改写toString()提供一个好的 toString() 实现，可以使一个类使用起来更加愉快。当一个对象被传递给 println、字符串连接操作符(+)时，会自动调用toString()方法。 10. 谨慎改写 clone()Cloneable具有很多问题，推荐用拷贝构造函数来替代12public Person(Person person);public static Person newInstance(Person person); //静态工厂 &emsp;&emsp;一个拷贝构造函数可以带一个参数，它的类型可以是该类实现的一个适当的接口。例如，所有通用集合都实现了一个拷贝构造函数，它的参数类型时Collection或Map。假如有一个 LinkedList ，则可以 new ArrayList(l) 11. 考虑实现Comparable接口compareTo()方法与equals()方法的约定相似。当该对象小于、等于或大于指定对象时，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法比较，则抛出 ClassCastException 异常。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Object</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的创建和销毁]]></title>
    <url>%2F2018%2F12%2F07%2FeffectiveJava2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。 1. 考虑用静态工厂方法替代构造函数123public static Boolean valueOf(boolean b)&#123; return(b ? Boolean.TRUE : Boolean.FALSE);&#125; 好处 与构造函数不同，静态工厂方法拥有名字，可以使一个类更易与使用，代码更易读 每次被调用时，不要求非得创建一个对象把已经构造好的实例缓存起来，避免频繁创建相同的对象 可以返回一个原返回类型子类的对象 缺点 如果类不含有公有的或受保护的构造函数，就不能被子类化 与其他的静态方法没有任何区别在API文档中，不会像构造函数那样被明显标示出来。静态工作方法应遵守标准的命名规范，如 getInstance 2. 使用私有构造函数强化singleton属性&emsp;&emsp;singleton通常被用来指代那些本质上具有唯一性的系统组件，比如系统显示或文件系统。&emsp;&emsp;实现单例有两种方法，都要把构造函数保持为私有的，并且提供一个静态成员，以便允许客户能访问到该类唯一的实例。 1234567public class Singleton&#123; public static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125;&#125; 第二种提供了一个公有的静态方法，而不是公有的静态final域。1234567891011public class Singleton&#123; private static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125; public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125; 当序列化遇到单例时,就会出现问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求一个JVM中只有一个类对象的, 而现在通过反序列化,一个新的对象克隆了出来。加入readResolve方法：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE&#125; 尽管构造函数是私有的，但可序列化工具具有创建类实例的特殊访问权限—— 被实例化的类上的私有方法，称为readResolve（）。 3. 私有化构造函数使类不能实例化这样的工具类(utility class)不希望被实例化，让其包含单个显式的私有构造函数123456public class utilityClass&#123; private utilityClass&#123; &#125; ...&#125; 4. 避免创建重复的对象反面例子：1String s = new String("silly"); // DOn't DO THIS! 应当：1String s = "no longer silly"; 5. 消除过期的对象引用一个可能引起内存泄漏的例子（用数组实现栈）：123456789101112131415161718192021222324252627282930public class Stack&#123; private Object[] elements; private int size = 0; public Stack(int initialCapacity)&#123; this.size = new Object[initialCapacity]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; /** * 确保容量 **/ private void ensureCapacity()&#123; if(elements.length == size)&#123; Object[] oldElements = elements; elements = new Object[2 * size + 1]; System.arraycopy(oldElements, 0, elements, 0, size); &#125; &#125;&#125; 问题：如果一个栈先增长，再弹出，那么弹出的对象不会被当做垃圾回收。 修复：一旦对象引用已经过期，将其置空。pop()方法修改：12345678public Object pop()&#123; if(size == 0)&#123; throw ... &#125; Object result = element[--size]; element[size] = null; return result;&#125; 6. 避免使用终结函数(finalize)如果一个子类改写了终结函数，那么子类的终结函数必须手工调用超类的终结函数:1super.finalize();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Object</tag>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
