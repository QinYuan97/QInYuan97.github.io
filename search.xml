<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[类和接口]]></title>
    <url>%2F2018%2F12%2F09%2FeffectiveJava4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;类和接口是Java程序设计语言的核心，也是Java语言的基本抽象单元。本章的一些指导原则，可以帮助更好的利用这些语言元素，使设计出来的类和接口更将有用、健壮和灵活。 12. 使类和成员的可访问能力最小化&emsp;&emsp;一个设计良好的模块应当隐藏所有的实现细节，把API与实现清晰的隔离起来。然后，模块之间，只通过API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为封装。&emsp;&emsp;封装可以有效的解除一个系统中各模块之间的耦合关系，使得这些模块可以被独立的开发、测试、优化、使用、理解和修改。 四种访问级别 私有的(private)——只有在该类的内部才能访问 包级私有(default)——声明该成员的包内部的任何类都可以访问这个成员 保护的(protected)——子类和包内可访问 公有的(public)——任何地方都能访问 13. 支持非可变性&emsp;&emsp;一个非可变类是一个简单的类，它的实例不能被修改。每个实例中所包含的信息都必须在该实例被创建时就提供出来，并且在对象的整个生存期内固定不变。比如 String 类、原语类型的包装类、BigInteger、BigDecimal等。&emsp;&emsp;为使一个类成为非可变类，要遵循下面五条规则： 不要提供任何会修改对象的方法（也称为 mutator） 保证没有可被子类改写的方法使这个类称为 final 的 使所有域都是 final 的 使所有域称为私有的 保证对于任何可变组件的互斥访问如果该类具有指向可变对象的域，则必须保证客户不能获得这些指向这些对象的引用。不能用客户提供的对象引用来初始化这样的域 &emsp;&emsp;非可变类的优点： 非可变对象比较简单只有一个状态，即最初被创建时的状态 本质上是线程安全的，不需要同步 非可变对象为其他对象，提供了大量的构件 &emsp;&emsp;非可变类唯一的缺点是，对于每一个不同的值都要求一个单独的对象，创建这样的对象可能会代价很高。 14. 复合优于继承(类继承)&emsp;&emsp;一个子类依赖于其超类中特定功能的实现细节，继承打破了封装性。 &emsp;&emsp;假设我们需要查询 HashSet，看它自被创建以来曾经有多少个元素被加了进来，继承 HashSet 类的方法：1234567891011121314151617181920212223242526public class InstrumentedHashSet extends HashSet&#123; //加入的次数 private int addCount = 0; public InstrumentedHashSet()&#123; &#125; public InstrumentedHashSet(Collection c)&#123; super(c); &#125; public boolean add(Object o)&#123; addCount++; return super.add(o); &#125; public boolean addAll(Collection c)&#123; addCount += c.size(); return super.addAll(); &#125; public int getAddCount()&#123; return addCount; &#125;&#125; &emsp;&emsp;这个类看起来非常合理，实际上是错误的。在 HasgSet 的内部，addAll方法是基于 add 实现的，所以调用一次这个类的 addAll，实际加了两次 addCount。&emsp;&emsp;用 复合 (composition)：12345678910111213141516171819202122public class InstrumentedSet implements Set&#123; private final Set s; private int addCount = 0; public InstrumentedSet(Set s)&#123; this.s = s; &#125; public boolean add(Object o)&#123; addCount++; return s.add(o); &#125; public boolean addAll(Collection c)&#123; addCount += c.size(); return s.addAll(c); &#125; ... // 待实现的方法 ...&#125; &emsp;&emsp;每一个InstrumentedSet实例都把另一个Set实例包装起来了，所以InstrumentedSet被称作包装类，这是装饰者模式。 16. 接口优于抽象类&emsp;&emsp;使用抽象类比使用接口的优势：抽象类的演化(比如增加一个新的方法)比接口的演化容易得多， 18. 嵌套类的使用&emsp;&emsp;嵌套类是指被定义在另一个类内部的类，存在的目的只是为它的外围类服务。 静态成员类最简单地内部类，可以访问外围类的所有成员，包括私有的成员。如果成员类不要求访问外围实例，则声明为静态的。 非静态成员类非静态成员类的每一个实例都与外围类的一个外围实例紧密关联在一起 匿名类匿名类通常只实现其接口中或超类中的方法，不会声明任何新的方法。 局部类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Note</tag>
        <tag>Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招正式结束后的总结与感想]]></title>
    <url>%2F2018%2F12%2F07%2Flife1%2F</url>
    <content type="text"><![CDATA[更多…… 迷茫&emsp;&emsp;在大三下学期的那段时间里吧，突然发现自己保研有些悬，去找实习很不顺利，上的课程也感觉有些困难，没心思学。一度陷入了高一时那种失眠的状态，半夜爬起来甚至想从阳台跳下去，怀疑自己白读了十几年书。想搞信安竞赛确保推免，中途放弃了；想冲一下学习成绩，奈何操作系统和Windows安全，实在是没兴趣，也失败了。 准备&emsp;&emsp;于是下定决心找工作，选择了JavaWeb这个方向，在牛客网上做项目、看面经，在leetcode上刷题，甚至还买了久违的实体书。正式的准备应该是从七月开始的吧，中间也有过一些迷茫与懈怠，爸妈的鼓励和上海交大这几个字让我支撑了下来。期间回了一趟忠县，面对父母和亲朋好友的期待，也坚定了我的信心和勇气。 秋招&emsp;&emsp;回校之前那晚投了很多简历，第一次笔试时招行行用卡中心，第一次面试是在依图科技，感谢当时两个学长面试官的包容和优待，也是提升我的信心。也有一些面试体验不是很好，但也是帮助了我成长吧。&emsp;&emsp;在去小红书面试的路上，看见一对白发苍苍的夫妇，我想着会不会好人有好报，给他们让了座，他们慈祥的笑容和满怀的谢意让我真的庆幸做了这件事。也许是上天看见了吧，小红书的4轮面试都很简单，顺利通过。心中的巨石也算是落了地，不用担心失业了，准备着过一个舒适的中秋假期。&emsp;&emsp;中秋假期那三天，拿到了oppo的sp offer，15k 30w 着实让我激动了很久。从那以后也就开始放松了，放弃了很多机会。直到拼多多来学校宣讲，CTO的忽悠能力和高薪让我又豪情万丈，投简历、刷题、刷面经。两轮面试发挥的不好，本以为没戏了，都给爸妈说安心去成都了，也算是为秋招做一个完整的结尾，第一次和最后的面试都在金虹桥。没想hr突然打电话来hr面，最后给出了23k，40w+的offer，拼多多也在高速发展，实在没有拒绝的理由。 感想&emsp;&emsp;半年以前，永远不会相信自己能拿到这种数字的offer，也是一直给爸妈吹牛逼的40w，现在却实现了。选择真的和努力同样重要啊！如果当时选择了考研、或者选择了python、或者选择暑假去一个破地方实习，更久远一点，如果当时没选这个计算机相关的专业甚至没选择交大，现在不知会是怎样的情景和心情。缘分也是存在的吧，如果华为实习面试时没表现得那么傻比，可能就去华为实习然后白菜价转正了，如果拼多多宣讲时没有多问一句，就错过了。&emsp;&emsp;期间也发生了一些事，比如陈老师的意外。陈老师是我的伯乐，没有他也应该不会有我高考的成绩，这件事让我体会到了生命的脆弱和珍贵，珍惜身体的人！也希望他能好转起来。&emsp;&emsp;总而言之，一分耕耘，一分收获，加之正确的目标，成功并不遥远。从今天开始，我也在为工作做准备了，巩固并拓展专业知识，改善自己不擅长的方面（比如人际交往、沟通、ppt）。世俗的成功，我一定会达到的，然后再去探索人生的意义！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类的通用方法]]></title>
    <url>%2F2018%2F12%2F07%2FeffectiveJava3%2F</url>
    <content type="text"><![CDATA[Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。 7. 改写 equals 时的约定&emsp;&emsp;不改写equals的情况下，每个实例只与它自己相等，这种情况满足下列任何一个条件： 一个类的每一个实例本质上是唯一的代表了活动实体而不是值（value）的类，如 Thread。 不关心一个类是否提供“逻辑相等”的测试功能 超类已经改写了equals 一个类是私有的，或包级私有的，并且可以确定它的 equals 方法永远也不会调用。这种情形下，应该要改写equals方法，以免万一有一天它会被调用到：123public boolean equals(Object o)&#123; throw new UnsupportedOperationException();&#125; &emsp;&emsp;改写 equals 的约定： 自反性—— 一个对象等于其自身 对称从—— a.equals(b) 和 b.equals(a) 必须返回同样的结果 传递性—— a等于b，b等于c，则a等于c1234567891011121314public class ColorPoint extends Point&#123; private Color color; ... public boolean equals(Object o)&#123; if(!(o instanceof Point)) return false; //如果o是无色点，做忽略颜色的比较 if(!(o instanceof ColorPoint)) return o.equals(this); ColorPoint cp = (ColorPoint)o; return super.equals(o) &amp;&amp; cp.color = this.color; &#125;&#125; 这种方法提供了对称性，但牺牲了传递性，比如：123456789101112ColorPoint p1 = new ColorPoint(1, 1, blue);Point p2 = new Point(1,1);ColorPoint p3 = new ColorPoint(1, 1, red);``` 解决：（复合优于继承，tips14），不让 ColorPoint 继承 Point，而是在 ColorPoint 中加入一个私有的 Point 域```Javapublic class ColorPoint&#123; private Point point; private Color color; ...&#125; 一致性—— 如果两个对象相等，除非发生修改，否则必须始终保持相等 非空性—— 所有的对象都必须不等于 null 8. 改写 equals 时必须改写hashCode在每个改写了 equals 方法的类中，必须改写 hashCode 方法，使该类能与基于散列值(hash)的集合类一起正常运作。hashCode的预定： 如果一个对象的 equals 方法做比较所用到的信息没有被修改，那么调用 hashCode 方法必须返回同一整数 两个对象根据 equals 方法是相等的，那么hashCode方法产生同样的整数结果 不同对象的hashCode可以相同 一个好的hash函数 令int result = 17 或任意非零常数 对于对象每一个关键域 f（equals中用到的），完成以下步骤： a. 为该域计算int类型的的散列码c:i. boolean类型，c = f ? 0 : 1 ii. byte、short、char、int，c = (int)f iii. long类型，c = (int)(f ^ (f &gt;&gt;&gt; 32)) iv. float类型，c = Float.floatToIntBits(f) v. doubel类型，则先Double.doubleToLongBits(f)得到一个long类型的值 vi. 该域是一个对象引用，则递归调用 hashCode，如为null，则返回0 vii. 该域是一个数组，则把每一个元素当成单独的域处理 b. result = 37*result + c 返回result 测试 关键点 可以把冗余域排除在外 2.b中的乘法部分使得散列值依赖于域的顺序，这是合理的。例如不同字符排列的字符串是不同的。 缓存 hashCode1private volatile int hashCode = 0; 9. 总是要改写toString()提供一个好的 toString() 实现，可以使一个类使用起来更加愉快。当一个对象被传递给 println、字符串连接操作符(+)时，会自动调用toString()方法。 10. 谨慎改写 clone()Cloneable具有很多问题，推荐用拷贝构造函数来替代12public Person(Person person);public static Person newInstance(Person person); //静态工厂 &emsp;&emsp;一个拷贝构造函数可以带一个参数，它的类型可以是该类实现的一个适当的接口。例如，所有通用集合都实现了一个拷贝构造函数，它的参数类型时Collection或Map。假如有一个 LinkedList ，则可以 new ArrayList(l) 11. 考虑实现Comparable接口compareTo()方法与equals()方法的约定相似。当该对象小于、等于或大于指定对象时，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法比较，则抛出 ClassCastException 异常。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Object</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的创建和销毁]]></title>
    <url>%2F2018%2F12%2F07%2FeffectiveJava2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。 1. 考虑用静态工厂方法替代构造函数123public static Boolean valueOf(boolean b)&#123; return(b ? Boolean.TRUE : Boolean.FALSE);&#125; 好处 与构造函数不同，静态工厂方法拥有名字，可以使一个类更易与使用，代码更易读 每次被调用时，不要求非得创建一个对象把已经构造好的实例缓存起来，避免频繁创建相同的对象 可以返回一个原返回类型子类的对象 缺点 如果类不含有公有的或受保护的构造函数，就不能被子类化 与其他的静态方法没有任何区别在API文档中，不会像构造函数那样被明显标示出来。静态工作方法应遵守标准的命名规范，如 getInstance 2. 使用私有构造函数强化singleton属性&emsp;&emsp;singleton通常被用来指代那些本质上具有唯一性的系统组件，比如系统显示或文件系统。&emsp;&emsp;实现单例有两种方法，都要把构造函数保持为私有的，并且提供一个静态成员，以便允许客户能访问到该类唯一的实例。 1234567public class Singleton&#123; public static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125;&#125; 第二种提供了一个公有的静态方法，而不是公有的静态final域。1234567891011public class Singleton&#123; private static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125; public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125; 当序列化遇到单例时,就会出现问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求一个JVM中只有一个类对象的, 而现在通过反序列化,一个新的对象克隆了出来。加入readResolve方法：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE&#125; 尽管构造函数是私有的，但可序列化工具具有创建类实例的特殊访问权限—— 被实例化的类上的私有方法，称为readResolve（）。 3. 私有化构造函数使类不能实例化这样的工具类(utility class)不希望被实例化，让其包含单个显式的私有构造函数123456public class utilityClass&#123; private utilityClass&#123; &#125; ...&#125; 4. 避免创建重复的对象反面例子：1String s = new String("silly"); // DOn't DO THIS! 应当：1String s = "no longer silly"; 5. 消除过期的对象引用一个可能引起内存泄漏的例子（用数组实现栈）：123456789101112131415161718192021222324252627282930public class Stack&#123; private Object[] elements; private int size = 0; public Stack(int initialCapacity)&#123; this.size = new Object[initialCapacity]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; /** * 确保容量 **/ private void ensureCapacity()&#123; if(elements.length == size)&#123; Object[] oldElements = elements; elements = new Object[2 * size + 1]; System.arraycopy(oldElements, 0, elements, 0, size); &#125; &#125;&#125; 问题：如果一个栈先增长，再弹出，那么弹出的对象不会被当做垃圾回收。 修复：一旦对象引用已经过期，将其置空。pop()方法修改：12345678public Object pop()&#123; if(size == 0)&#123; throw ... &#125; Object result = element[--size]; element[size] = null; return result;&#125; 6. 避免使用终结函数(finalize)如果一个子类改写了终结函数，那么子类的终结函数必须手工调用超类的终结函数:1super.finalize();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Object</tag>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
