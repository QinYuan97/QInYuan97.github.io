<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis Notes(一)]]></title>
    <url>%2F2019%2F07%2F13%2FRedis-Notes%2F</url>
    <content type="text"><![CDATA[Redis设计与实现的一些笔记Redis性能高的几点原因： 纯内存操作 单线程 高效的数据结构 合理的数据编码 其他方面的优化 Redis 5种数据结构常用应用场景： String：缓存、计数器、分布式锁等 List：链表、队列等 Hash：用户信息、Hash表等 Set：去重、赞、踩、共同好友等 Zset：访问量排行榜、点击量排行榜等 SDSRedis 是用 C 语言开发完成的，但在 Redis 字符串中，并没有使用 C 语言中的字符串，而是用一种称为 SDS（Simple Dynamic String）的结构体来保存字符串。123456789struct sdshdr &#123;int len; // 记录 buf 中已使用空间的长度int free; // buf 中空闲的长度char buf; // 存储实际内容&#125; SDS和C字符串的区别常数时间内获得字符串长度C 字符串本身不记录长度信息，每次获取长度信息都需要遍历整个字符串，复杂度为 O(n)； C 字符串遍历时遇到 ‘\0’ 时结束。 避免缓冲区溢出假设在内存中有两个紧挨着的两个字符串，s1=“xxxxx”和 s2=“yyyyy”。 由于在内存上紧紧相连，当我们对 s1 进行扩充的时候，将 s1=“xxxxxzzzzz”后，由于没有进行相应的内存重新分配，导致 s1 把 s2 覆盖掉，导致 s2 被莫名其妙的修改。 但 SDS 的 API 对字符串修改时首先会检查空间是否足够，若不充足则会分配新空间，避免了缓冲区溢出问题。 减少字符串修改时带来的内存重新分配的次数在 C 中，当我们频繁的对一个字符串进行修改（append 或 trim）操作的时候，需要频繁的进行内存重新分配的操作，十分影响性能。 如果不小心忘记，有可能会导致内存溢出或内存泄漏，对于 Redis 来说，本身就会很频繁的修改字符串，所以使用 C 字符串并不合适。而 SDS 实现了空间预分配和惰性空间释放两种优化策略： 空间预分配当 SDS 的 API 对一个 SDS 修改后，并且对 SDS 空间扩充时，程序不仅会为 SDS 分配所需要的必须空间，还会分配额外的未使用空间。 分配规则如下：如果对 SDS 修改后，len 的长度小于 1M，那么程序将分配和 len 相同长度的未使用空间。 举个例子，如果 len=10，重新分配后，buf 的实际长度会变为 10(已使用空间)+10(额外空间)+1(空字符)=21。如果对 SDS 修改后 len 长度大于 1M，那么程序将分配 1M 的未使用空间。 惰性空间释放当对 SDS 进行缩短操作时，程序并不会回收多余的内存空间，而是使用 free 字段将这些字节数量记录下来不释放，后面如果需要 append 操作，则直接使用 free 中未使用的空间，减少了内存的分配。 二进制安全在 Redis 中不仅可以存储 String 类型的数据，也可能存储一些二进制数据。 二进制数据并不是规则的字符串格式，其中会包含一些特殊的字符如 ‘\0’，在 C 中遇到 ‘\0’ 则表示字符串的结束，但在 SDS 中，标志字符串结束的是 len 属性。 Hash字典是 Hash 的底层实现，其数据结构如下：12345678910111213141516171819202122232425262728293031typedef struct dict&#123;dictType *type;void *privdata;dictht ht[2];int trehashidx;&#125;typedef struct dictht&#123;//哈希表数组dectEntrt **table;//哈希表大小unsigned long size;//unsigned long sizemask;//哈希表已有节点数量unsigned long used;&#125; dictht 和 trehashidx，这两个字段与 rehash 有关 RehashRehash过程dict 中存储了一个 dictht 的数组，长度为 2，这两个哈希表 ht[0] 和 ht[1]就是为了Rehash，Rehash 的过程如下： 为 ht[1] 分配空间。如果是扩容操作，ht[1] 的大小为第一个大于等于 ht[0].used*2 的 2^n；如果是缩容操作，ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n。 将 ht[0] 中的键值 Rehash 到 ht[1] 中。 当 ht[0] 全部迁移到 ht[1] 中后，释放 ht[0]，将 ht[1] 置为 ht[0]，并为 ht[1] 创建一张新表，为下次 Rehash 做准备。 渐进式Rehash由于 Redis 的 Rehash 操作是将 ht[0] 中的键值全部迁移到 ht[1]，如果数据量小，则迁移过程很快。但如果数据量很大，一个 Hash 表中存储了几万甚至几百万几千万的键值时，迁移过程很慢并会影响到其他用户的使用。 为了避免 Rehash 对服务器性能造成影响，Redis 采用了一种渐进式 Rehash 的策略，分多次、渐进的将 ht[0] 中的数据迁移到 ht[1] 中。这一过程如下： 为 ht[1] 分配空间，让字典同时拥有 ht[0] 和 ht[1] 两个哈希表。 字典中维护一个 rehashidx，并将它置为 0，表示 Rehash 开始。 在 Rehash 期间，每次对字典操作时，程序还顺便将 ht[0] 在 rehashidx 索引上的所有键值对 rehash 到 ht[1] 中，当 Rehash 完成后，将 rehashidx 属性+1。当全部 rehash 完成后，将 rehashidx 置为 -1，表示 rehash 完成。 另外，在 Rehash 过程中，字典会同时使用 ht[0] 和 ht[1]。所以在删除、查找、更新时会在两张表中操作，在查询时会先在第一张表中查询，如果第一张表中没有，则会在第二张表中查询。但新增时一律会在 ht[1] 中进行，确保 ht[0] 中的数据只会减少不会增加。 跳跃表Zset 是一个有序的链表结构，其底层的数据结构是跳跃表 skiplist，其结构如下：1234567891011121314151617181920212223242526272829303132333435363738394041typedef struct zskiplistNode &#123;//成员对象robj *obj;//分值double score;//后退指针struct zskiplistNode *backward;//层struct zskiplistLevel &#123;struct zskiplistNode *forward;//前进指针unsigned int span;//跨度&#125; level;&#125; zskiplistNode;typedef struct zskiplist &#123;//表头节点和表尾节点struct zskiplistNode *header, *tail;//表中节点的的数量unsigned long length;//表中层数最大的节点层数int level;&#125; zskiplist; 前进指针:用于从表头向表尾方向遍历。 后退指针:用于从表尾向表头方向回退一个节点，和前进指针不同的是，前进指针可以一次性跳跃多个节点，后退指针每次只能后退到上一个节点。 跨度:表示当前节点和下一个节点的距离，跨度越大，两个节点中间相隔的元素越多。在查询过程中跳跃着前进。由于存在后退指针，如果查询时超出了范围，通过后退指针回退到上一个节点后仍可以继续向前遍历。 压缩列表压缩列表 ziplist 是为 Redis 节约内存而开发的，是列表键和字典键的底层实现之一。 当元素个数较少时，Redis 用 ziplist 来存储数据，当元素个数超过某个值时，链表键中会把 ziplist 转化为 linkedlist，字典键中会把 ziplist 转化为 hashtable。 ziplist 是由一系列特殊编码的连续内存块组成的顺序型的数据结构，ziplist 中可以包含多个 entry 节点，每个节点可以存放整数或者字符串。 编码转化Redis 使用对象（redisObject）来表示数据库中的键值，当我们在 Redis 中创建一个键值对时，至少创建两个对象，一个对象是用做键值对的键对象，另一个是键值对的值对象。 redisObject 的结构如下：1234567891011121314151617typedef struct redisObject&#123;//类型unsigned type:4;//编码unsigned encoding:4;//指向底层数据结构的指针void *ptr;//...&#125;robj; 其中 type 字段记录了对象的类型，包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象。ptr 指针字段指向对象底层实现的数据结构，而这些数据结构是由 encoding 字段决定的，每种对象至少有两种数据编码： 过期数据的删除 定时删除：在设置键的过期时间的同时，创建一个定时器 Timer，让定时器在键过期时间来临时立即执行对过期键的删除 惰性删除：键过期后不管，每次读取该键时，判断该键是否过期，如果过期删除该键返回空。 定期删除：每隔一段时间对数据库中的过期键进行一次检查。 定时删除对内存友好，对 CPU 不友好。如果过期删除的键比较多的时候，删除键这一行为会占用相当一部分 CPU 性能，会对 Redis 的吞吐量造成一定影响。 惰性删除对 CPU 友好，内存不友好。如果很多键过期了，但在将来很长一段时间内没有很多客户端访问该键导致过期键不会被删除，占用大量内存空间。 定期删除是定时删除和惰性删除的一种折中。每隔一段时间执行一次删除过期键的操作，并且限制删除操作执行的时长和频率。具体的操作如下： Redis 会将每一个设置了 expire 的键存储在一个独立的字典中，以后会定时遍历这个字典来删除过期的 key。除了定时遍历外，它还会使用惰性删除策略来删除过期的 key。 Redis 默认每秒进行十次过期扫描，过期扫描不会扫描所有过期字典中的 key，而是采用了一种简单的贪心策略。从过期字典中随机选择 20 个 key；删除这 20 个 key 中已过期的 key；如果过期 key 比例超过 1/4，那就重复上述步骤。 同时，为了保证在过期扫描期间不会出现过度循环，导致线程卡死，算法还增加了扫描时间上限，默认不会超过 25ms。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F07%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Head First设计模式笔记 策略模式模式定义定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 问题描述设计不同种类的鸭子拥有不同的叫声和飞行方式。 简单实现方案使用继承的解决方案如下，这种方案代码无法复用，如果两个鸭子类拥有同样的飞行方式，就有两份重复的代码。 设计原则封装变化：在这里变化的是鸭子叫和飞行的行为方式。针对接口编程，而不是针对实现编程：变量声明的类型为父类，而不是具体的某个子类。父类中的方法实现不在父类，而是在各个子类。程序在运行时可以动态改变变量所指向的子类类型。 运用这一原则，将叫和飞行的行为抽象出来，实现多种不同的叫和飞行的子类，让子类去实现具体的叫和飞行方式。 多用组合，少用继承：组合也就是 HAS-A 关系，通过组合，可以在运行时动态改变实现，只要通过改变父类对象具体指向哪个子类即可。而继承就不能做到这些，继承体系在创建类时就已经确定。 运用这一原则，在 Duck 类中组合 FlyBehavior 和 QuackBehavior 类，performQuack() 和 performFly() 方法委托给这两个类去处理。通过这种方式，一个 Duck 子类可以根据需要去初始化 FlyBehavior 和 QuackBehavior 的子类对象，并且也可以动态地进行改变。 问题的解决方案类图 观察者模式模式定义定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。 模式类图主题具有注册和移除观察者、并通知所有注册者的功能，主题是通过维护一张观察者列表来实现这些操作的。 观察者拥有一个主题对象的引用，因为注册、移除观察者功能，还有数据都在主题当中，必须通过操作主题才能完成相应操作。 问题描述天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。 问题的解决方案类图 设计原则为交互对象之间的松耦合设计而努力：当两个对象之间松耦合，它们依然可以交互，但是不清楚彼此的细节。由于松耦合的两个对象之间互相依赖程度很低，因此系统具有弹性，能够应对变化。 代码实现12345public interface Subject &#123; public void resisterObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver();&#125; 12345678910111213141516171819202122232425262728293031323334353637public class WeatherData implements Subject &#123; private List&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;&gt;(); &#125; @Override public void resisterObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; @Override public void notifyObserver() &#123; for (Observer o : observers) &#123; o.update(temperature, humidity, pressure); &#125; &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); &#125;&#125; 123public interface Observer &#123; public void update(float temp, float humidity, float pressure);&#125; 12345678910111213public class CurrentConditionsDisplay implements Observer &#123; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.resisterObserver(this); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; System.out.println("CurrentConditionsDisplay.update:" + temp + " " + humidity + " " + pressure); &#125;&#125; 12345678910111213public class StatisticsDisplay implements Observer &#123; private Subject weatherData; public StatisticsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.resisterObserver(this); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; System.out.println("StatisticsDisplay.update:" + temp + " " + humidity + " " + pressure); &#125;&#125; 12345678910public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); weatherData.setMeasurements(0, 0, 0); weatherData.setMeasurements(1, 1, 1); &#125;&#125; 装饰模式问题描述设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。 模式定义动态地将责任附加到对象上。在扩展功能上，装饰者提供了比继承更有弹性的替代方案。 下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。 模式类图装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。 问题的解决方案类图 设计原则类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。在本章问题中该原则体现在，饮料可以动态添加新的配料，而不需要去修改饮料的代码。观察则模式也符合这个原则。不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。 Java IO中的装饰模式 代码实现123public interface Beverage &#123; public double cost();&#125; 123456789101112public class HouseBlend implements Beverage&#123; @Override public double cost() &#123; return 1; &#125;&#125;public class DarkRoast implements Beverage&#123; @Override public double cost() &#123; return 1; &#125;&#125; 123public abstract class CondimentDecorator implements Beverage&#123; protected Beverage beverage;&#125; 12345678910111213141516171819202122public class Mocha extends CondimentDecorator &#123; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double cost() &#123; return 1 + beverage.cost(); &#125;&#125;public class Milk extends CondimentDecorator &#123; public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double cost() &#123; return 2 + beverage.cost(); &#125;&#125; 12345678public class StartbuzzCoffee &#123; public static void main(String[] args) &#123; Beverage beverage = new HouseBlend(); beverage = new Mocha(beverage); beverage = new Milk(beverage); System.out.println(beverage.cost()); &#125;&#125; 输出14.0 简单工厂问题描述Pizza 类有很多子类，要求根据不同的情况用不同的子类实例化一个 Pizza 对象。 模式定义简单工厂不是设计模式，更像是一种编程习惯。它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个子类来实例化。 这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。因为客户类往往有多个，如果不使用简单工厂，所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。 问题的解决方案类图 代码实现123public interface Pizza &#123; public void make();&#125; 123456public class CheesePizza implements Pizza&#123; @Override public void make() &#123; System.out.println("CheesePizza"); &#125;&#125; 123456public class GreekPizza implements Pizza&#123; @Override public void make() &#123; System.out.println("GreekPizza"); &#125;&#125; 1234567891011public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; if (type.equals("cheese")) &#123; return new CheesePizza(); &#125; else if (type.equals("greek")) &#123; return new GreekPizza(); &#125; else &#123; throw new UnsupportedOperationException(); &#125; &#125;&#125; 1234567public class PizzaStore &#123; public static void main(String[] args) &#123; SimplePizzaFactory simplePizzaFactory = new SimplePizzaFactory(); Pizza pizza = simplePizzaFactory.createPizza("cheese"); pizza.make(); &#125;&#125; 工厂方法模式问题描述每个地区的 PizzaStore 卖的 Pizza 虽然种类相同，但是都有自己的风味。一个客户点了纽约的 cheese 种类的 Pizza 和在芝加哥点的相同种类的 Pizza 是不同的。要求设计出满足条件的 PizzaStore。 模式定义定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化推迟到子类。 模式类图在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。 下图中，Creator 有一个 anOperation() 方法，这个方法需要用到一组产品对象，这组产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。 问题的解决方案类图PizzaStore 有 orderPizza() 方法，顾客可以用它来下单。下单之后需要先使用 createPizza() 来制作 Pizza，这里的 createPizza() 就是 factoryMethod()，不同的 PizzaStore 子类实现了不同的 createPizza()。 设计原则依赖倒置原则：要依赖抽象，不要依赖具体类。听起来像是针对接口编程，不针对实现编程，但是这个原则说明了：不能让高层组件依赖底层组件，而且，不管高层或底层组件，两者都应该依赖于抽象。例如，下图中 Pizza 是抽象类，PizzaStore 和 Pizza 子类都依赖于 Pizza 这个抽象类。 代码实现123public interface Pizza &#123; public void make();&#125; 123public interface PizzaStore &#123; public Pizza orderPizza(String item);&#125; 123456789101112131415161718192021222324252627public class NYStyleCheesePizza implements Pizza&#123; @Override public void make() &#123; System.out.println("NYStyleCheesePizza is making.."); &#125;&#125;public class NYStyleVeggiePizza implements Pizza &#123; @Override public void make() &#123; System.out.println("NYStyleVeggiePizza is making.."); &#125;&#125;public class ChicagoStyleCheesePizza implements Pizza&#123; @Override public void make() &#123; System.out.println("ChicagoStyleCheesePizza is making.."); &#125;&#125;public class ChicagoStyleVeggiePizza implements Pizza&#123; @Override public void make() &#123; System.out.println("ChicagoStyleVeggiePizza is making.."); &#125;&#125; 12345678910111213141516171819202122232425262728293031public class NYPizzaStore implements PizzaStore &#123; @Override public Pizza orderPizza(String item) &#123; Pizza pizza = null; if (item.equals("cheese")) &#123; pizza = new NYStyleCheesePizza(); &#125; else if (item.equals("veggie")) &#123; pizza = new NYStyleVeggiePizza(); &#125; else &#123; throw new UnsupportedOperationException(); &#125; pizza.make(); return pizza; &#125;&#125;public class ChicagoPizzaStore implements PizzaStore &#123; @Override public Pizza orderPizza(String item) &#123; Pizza pizza = null; if (item.equals("cheese")) &#123; pizza = new ChicagoStyleCheesePizza(); &#125; else if (item.equals("veggie")) &#123; pizza = new ChicagoStyleVeggiePizza(); &#125; else &#123; throw new UnsupportedOperationException(); &#125; pizza.make(); return pizza; &#125;&#125; 12345678public class PizzaTestDrive &#123; public static void main(String[] args) &#123; PizzaStore nyStore = new NYPizzaStore(); nyStore.orderPizza("cheese"); PizzaStore chicagoStore = new ChicagoPizzaStore(); chicagoStore.orderPizza("cheese"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
        <tag>Note![d887219c-963a-4392-abe7-d3967546e96d](https://i.loli.net/2019/07/03/5d1c9b10dc71b95020.jpg)![d887219c-963a-4392-abe7-d3967546e96d](https://i.loli.net/2019/07/03/5d1c9b1e9500979995.jpg)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SkipList跳表]]></title>
    <url>%2F2019%2F06%2F18%2F%E8%B7%B3%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[调表的基本原理 跳表的搜索链表示有序的，但是不能二分查找，所以将一些节点提取出来作为索引，形成多层的链表，减少比较次数。跳表的结构如下： 跳表具有如下性质： 多层链表 每一层都是一个有序链表 最底层的链表包含所有元素 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。 查找元素117的过程：具体的搜索算法：123456789101112find(x)&#123; p = top; while(1)&#123; while(p.next.key &lt; x)&#123; p = p.next; &#125; if(p.down == NULL)&#123; return p.next; &#125; p = p.down; &#125;&#125; 跳表的插入先确定该元素要占据的层数K (随机或使用特定算法)然后在 Level1 1… Level K 各个层的链表都插入元素]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SkipList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的注解]]></title>
    <url>%2F2019%2F06%2F17%2FJava%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[介绍 Java 中注解的原理和一些常用的注解 什么是注解注解是一种元数据，即描述数据的数据，应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。java.lang.annotation 提供四种元注解，专门注解其它的注解： @Documented 是否将注解信息添加在 java 文档中。 @Retention 定义该注解的生命周期 RetentionPolicy.SOURCE —— 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。RetentionPolicy.CLASS —— 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。RetentionPolicy.RUNTIME —— 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。自定义的注解通常使用这种方式。 @Target 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方 ElementType.TYPE: 用于描述类、接口或enum声明ElementType.FIELD: 用于描述实例变量ElementType.METHODElementType.PARAMETERElementType.CONSTRUCTORElementType.LOCAL_VARIABLEElementType.ANNOTATION_TYPE 另一个注释ElementType.PACKAGE 用于记录java文件的package信息 @Inherited 是否允许子类继承该注解 自定义注解注解的内部只支持基本类型、String及枚举类型。注释中所有的属性被定义成方法，并允许提供默认值。123456789@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Todo &#123; public enum Priority &#123;LOW, MEDIUM, HIGH&#125;; public enum Status &#123;STARTED, NOT_STARTED&#125;; String author() default "Yash"; Priority priority() default Priority.LOW; Status status() default Status.NOT_STARTED;&#125; 使用上面的注解：12345@Todo(priority = Todo.Priority.MEDIUM, author = "Yashwant", status = Todo.Status.STARTED)public void incompleteMethod1() &#123;//Some business logic is written//But it’s not complete yet&#125; 如果注解中只有一个属性，可以直接命名为“value”，使用时无需再标明属性名。1234567@interface Author&#123;String value();&#125;@Author("Yashwant")public void someMethod() &#123;&#125; 在用户程序中使用反射机制调用自定义注解：12345678910Class businessLogicClass = BusinessLogic.class;for(Method method : businessLogicClass.getMethods()) &#123; Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class); if(todoAnnotation != null) &#123; System.out.println(" Method Name : " + method.getName()); System.out.println(" Author : " + todoAnnotation.author()); System.out.println(" Priority : " + todoAnnotation.priority()); System.out.println(" Status : " + todoAnnotation.status()); &#125;&#125; Spring 中常用注解 Controller注解一个类表示控制器，Spring MVC会自动扫描标注了这个注解的类。 RequestMapping请求路径映射，可以标注类，也可以是方法，可以指定请求类型，默认不指定为全部接收。 RequestParam放在参数前，用于将URL中的参数绑定到处理函数方法的变量中。 RequestBody放在参数前，表示参数从request body中获取，而不是从 url 获取。 ResponseBody放在方法上前，表示此方法返回的数据放在response body里面，而不是跳转页面。一般用于ajax请求，返回json数据。 PathVariable路径绑定变量，用于绑定restful路径上的变量。 RequestHeader放在方法参数前，用来获取request header中的参数值。 CookieValue放在方法参数前，用来获取request header cookie中的参数值。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Spring</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bitmap算法]]></title>
    <url>%2F2019%2F06%2F17%2Fbitmap%2F</url>
    <content type="text"><![CDATA[bitmap在1亿个整数里面快速查找某个整数是否存在其中，使用 bitmap 算法：用一个比特位来表示一个数 假设原有的 bitmap 中存储了4和12这两个数字，则结构为： 存储一个数的过程：12345678910public void set(int number)&#123; //除以8，即所在的byte[]数组的索引 int index = number &gt;&gt; 3; // mod 8，即 byte[index] 的位置 int position = number % 0x07; //或运算，将 byte[index]的第 position 位置为1 byte[index] |= 1 &lt;&lt; position;&#125; 判断一个数是否存在：1234567public boolean contain(int number)&#123; int index = number &gt;&gt; 3; int position = number % 0x07; return (byte[index] &amp; (1 &lt;&lt; position)) != 0;&#125; 布隆过滤器假如一千万个数字，但是数字范围不是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，也就是 120MB 的大小，消耗的内存空间加大了，而且在bitmap里面还会有部分空间浪费的情况存在。 假设我们对每一个数字都进行一次hash计算，然后通过hash将计算后的结果范围限制在1千万里面，那么就不需要再定义10亿个二进制位了。但是这样子还是会有相应的弊端，例如说hash冲突。那么这个时候如果我们采用多个hash函数来进行处理的话，理论上是可以大大降低冲突的概率的。于是就有了下边所说的布隆过滤器一说。 布隆过滤器通过使用多次的hash计算来进行数值是否存在的判断，虽然大大降低了hash冲突的情况，但是还是存在一定的缺陷，那就是会有误判的情况：某个不存在的数字可能会被判断为存在。 java里面提供了BitSet类，Redis也提供了相应的位图类，Google里面的guava工具包中的BloomFilter 也已经实现类布隆过滤器。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高效率的工具和代码]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;记录一些常用的提高效率的工具和代码 常用的类Objects类12345678import java.util.objectspublic static boolean equals(Object a, Object b);public static boolean deepEquals(Object a, Object b);public static boolean toString(Object o, String nullDefault); public static &lt;T&gt; T requireNonNull(T obj, String message); //检查是否为空public static boolean isNull(Object obj); public static boolean nonNull(Object obj); 为什么需要Java8中引入了lambda，因此出现很多 filter(Objects::nonNull) 这样的写法，比filter(x -&gt; x != null) 更直观一些1234List&lt;String&gt; list1 = Arrays.asList("a", "b", null, null);List&lt;String&gt; list2 = list.stream() .filter(Objects::nonNull) .collect(Collectors.toList()); Optional类Optional 类是一个可以为null的容器对象，不用显示进行空值检测，很好的解决了空指针异常1234import java.util.Optional;Optional.ofNullable(request.getWord()).ifPresent(word::setWord);word.setWord(Optional.ofNullable(request.getWord()).orElse("")); 常用的工具Lombok @NonNull: 作用于成员变量和参数 @RequiredArgsConstructor: 生成包含 final 和 @NonNull注解的成员变量的构造器 @NoArgsConstructor: 无参构造器 @AllArgsConstructor: 全参构造器 @Clearup: 自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如典型的IO流对象 1@Cleanup InputStream in = new FileInputStream(file); @SneakyThrows: 对受检异常进行捕捉并抛出 @EqualsAndHashCode: 默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。 @Data: 包含@ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合 @Log: 作用于类，创建一个log属性 常用的代码Java8 StreamStream方式将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等stream of elements -&gt; filter -&gt; sorted -&gt; map -&gt; collect filter设置条件过滤出元素 12//过滤出空字符串int nullCount = strings.stream().filter(Objects::isNull).count(); mapmap方法用于映射每个元素到对应的结果 forEach迭代流中的每个元素 1numList.stream().limit(5).forEach(System.out::println); limit用于获取指定数量的流 sorted对流进行排序 CollectorsCollectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。可用于返回列表或字符串12stream().collect(Collectors.toList());stream().collect(Collectors.joining(",")); 读取文本文件12345678910111213141516171819202122232425262728public class ReadText&#123; public List&lt;String&gt; read(InputStream in)&#123; try&#123; BufferedReader br = new BufferedReader(new InputStreamReader(in)); String line; List&lt;String&gt; result = new ArrayList&lt;&gt;(); while((line = br.readLine()) != null)&#123; result.add(line); &#125; return result; &#125; catch(IOException e)&#123; throw new RuntimeException("error in reading"); &#125; finally&#123; if(in != null)&#123; try&#123; in.close(); &#125; catch(IOException e)&#123; // do nothing &#125; &#125; &#125; &#125; // inputStream 可以两种方式读取 InputStream in = new FileInputStream(new File(filePath)); InputStream in = ReadText.class.getResourceAsStream(fileName); //文件放在 resources目录下，加 /&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot实战系列]]></title>
    <url>%2F2019%2F02%2F07%2FSpring%20Boot%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[转载自CodeSheep程序羊 数据库/缓存相关 Guava Cache本地缓存在 Spring Boot应用中的实践 EVCache缓存在 Spring Boot中的实战 Spring Boot应用缓存实践之：Ehcache加持 Spring Boot集成 MyBatis和 SQL Server实践 Elasticsearch搜索引擎在Spring Boot中的实践 日志相关 Spring Boot日志框架实践 应用监控相关 利用神器 BTrace 追踪线上 Spring Boot应用运行时信息 Spring Boot应用监控实战 Spring Boot Admin 2.0开箱体验 内部机制相关 SpringBoot 中 @SpringBootApplication注解背后的三体结构探秘 SpringBoot 应用程序启动过程探秘 如何自制一个Spring Boot Starter并推送到远端公服 实战经验相关 Spring Boot工程集成全局唯一ID生成器 UidGenerator Spring Boot 工程集成全局唯一ID生成器 Vesta Spring Boot优雅编码之：Lombok加持 Spring Boot应用 Docker化 Spring Boot热部署加持 基于Spring Boot实现图片上传/加水印一把梭操作 从Spring Boot到 SpringMVC 自然语言处理工具包 HanLP在 Spring Boot中的应用 Spring Boot应用部署于外置Tomcat容器]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的使用]]></title>
    <url>%2F2019%2F01%2F04%2FgitNote%2F</url>
    <content type="text"><![CDATA[git 的基本概念和操作 常用命令 git init在当前目录下初始化 git 仓库 git status查看当前 git 仓库的状态 git add1234git add a.md 将文件提交到缓存区(防止误提交)git add . 把所有变化提交到暂存区，但不包括被删除的文件git add -u 仅监控已被 add 的文件，不会提交新文件git add -A 提交所有 git commit12git commit -m &apos;first commit&apos; git commit -a -m &quot;commit&quot; 跳过add，自动把已跟踪过的文件暂存提交 git log查看所有的 commit 记录 git branch 1234git branch 查看当前分支情况git branch a 在当前分支下新建一个叫 a 的分支，此时内容完全一样git branch -d a 删除分支 agit branch -D a 可能还未合并，强制删除 git checkout123456git checkout a 切换到 a 分支下git checkout -b a 新建并切换到 agit checkout a.md 还原文件，只能撤销还未 add 进缓存区的文件git checkout -b local origin/master 从远程master新建本地仓库git checkout -- file 撤销暂存区中文件的修改 git merge1git merge a 在主分支下把分支 a 的代码合并过来 git diff12git diff 查看工作目录中文件和暂存区的差异git diff --cached 查看已暂存的将要添加到下次提交的内容 git remove 1git rm --cached 从git中删除，但保留在磁盘上 git reset 1git reset HEAD file 取消暂存 git tag 12git tag v1.0 在当前状态下新建一个标签git checkout v1.0 切换到 v.1.0 的代码状态 push &amp; pullpush：本地代码有更新，推到远程仓库1git push origin master &emsp;&emsp;pull：别人提交代码到远程仓库，把远程仓库的最新代码拉下来。一般 push 之前先 pull，不容易冲突1git pull origin master 提交代码1git clone git@...git 将远程项目 clone 到本地1git push origin master 提交代码到远程仓库1git remote add origin git@...git 将本地项目与 github 上的项目关联，origin 是远程仓库的名字12git config —global user.name &quot;qinyuan&quot;git config —global user.email &quot;qinyuan1997@gmail.com&quot; 设置用户名和邮箱（去掉 -global 参数，在某一项目中使用特定的邮箱） stash在暂时不能 commit 的情况下暂存代码1git stash 把当前分支所有没有 commit 的代码都暂存起来，但是看不见任何改动1git stash list 查看暂存区记录1git stash apply 还原暂存的代码123git stash drop 删除暂存区的这次 stash 记录git stash pop 还原并删除 stash 记录git stash clear 删除所有 stash 记录]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用服务器变为集群后的Session问题]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E4%B8%BA%E9%9B%86%E7%BE%A4%E5%90%8E%E7%9A%84Session%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;HTTP 协议本身是无状态的，需要基于 HTTP 协议支持会话状态(Session State)的机制。这样的机制使 Web 服务器从多次单独的 HTTP 请求中看到会话，即知道哪些请求是来自哪些会话的。&emsp;&emsp;具体实现方式：在会话开始时，分配一个唯一的会话标识(SessionId)，通过 Cookie 把这个标识告诉浏览器，以后每次请求的时候，浏览器都会带上这个标识来告诉 Web 服务器请求是属于哪个会话的。在 Web 服务器上，每个会话有独立的存储，保存不同会话的信息。如果遇到禁用 Cookie 的情况，一般就把这个会话标识放到URL的参数。&emsp;&emsp;Session 问题：会话数据是保存在单机上的，要保证每一次请求都落在同一个服务器上。 Session Sticky&emsp;&emsp;让负载均衡器能够根据每次请求的会话标识来进行请求转发。&emsp;&emsp;这个方案非常简单，但有一些问题： 如果一台 Web 服务器崩溃或者重启，这台机器上的会话数据就会丢失。 会话标识是应用层的信息，那么负载均衡器要将用一个会话的请求都保存到同一个 Web 服务器上的话，就需要进行应用层的解析，这个开销比第4层的交换要大。 负载均衡器变为了一个有状态的节点，要将会话保存到具体 Web 服务器的映射。和无状态的节点相比，内存消耗更大，容灾方面更麻烦。 Session Replication&emsp;&emsp;Web 服务器之间增加会话数据的同步，保证不同 Web 服务器之间的 Session 书籍的一致。 同步 Session 数据造成了网络带宽的开销。只要 Session 数据有变化，就需要将数据同步到所有其他机器上，机器数越多，同步带来的网络带宽开销就越大。 每台 Web 服务器都要保存所有的 Session 数据，如果整个集群的 Session 数很多，每天机器用于保存 Session 数据的内存占用严重。 &emsp;&emsp;Session Replication 方案是靠应用容器开完成 Session 的复制，应用本身不用关心这个事情。但是，这个方案不适合集群机器数多的场景。 Session 数据集中存储&emsp;&emsp;把Session数据集中存储起来，然后不同 Web 服务器从同一个地方来获取 Session。&emsp;&emsp;存在的问题： 读写 Session 数据引入了网络操作，存在时延和不稳定性。 如果集中存储 Session 的机器或者集群有问题，就会影响应用。 Cookie Based&emsp;&emsp;把 Session 数据放在 Cookie 中，然后在 Web 服务器上从 Cookie 中生成对应的 Session 数据。好比每次都把自己的碗筷带在身上，这样去哪家饭店吃饭就介意随意选择。 Cookie 长度的限制。 安全性问题 每次 HTTP 请求和响应都带有 Session 数据，对性能有影响。 对于大型网站来说，Session Sticky 和 Session 集中存储是比较好的方案。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用技巧]]></title>
    <url>%2F2018%2F12%2F15%2FIntelliJ%20IDEA%2F</url>
    <content type="text"><![CDATA[常见的 IntelliJ IDEA使用技巧整理 编辑(Edit) Ctrl + X 删除一行 Ctrl + W 扩大选择范围 Ctrl + D 复制一行 Ctrl + Shift + 左右箭头 扩大光标选择范围 Ctrl + Shift + U 转换大小写 Ctrl + Shift + V 调出剪切板 Ctrl + R 在文件中查找并替换 Ctrl + Shift + R 查找并替换 Ctrl + Shift + F 查找 Ctrl + Alt + Shift + J 光标选中所有符合的视图(View) Ctrl + Shift + A Find Action Alt + 首字母 弹出对应选项 Alt + 1 跳转到 Project，之后 Ctrl+Shift+左右箭头 可移动分割线 F4 进入代码 Alt + 0 跳转到 Message Ctrl + Shift + F4 关闭 Alt + 4 跳转到 Run Alt + 6 跳转到 Todo Alt + F12 跳转到终端 Ctrl + Q 显示文档 Ctrl + P 显示方法参数 Ctrl + E 最近文件 Ctrl + Shift + E 最近修改文件导航 Alt + 上下箭头 方法之间跳转 Alt + 左右箭头 编辑区文件之间跳转 Ctrl + Alt + [ 或 ] 项目之间跳转 Ctrl + Shift + Backspace 跳转到上次编辑位置 Ctrl + Alt + 左右箭头 编辑位置跳转 Ctrl + G 跳转到行 Ctrl + N 查找类 Ctrl + Shift + N 查找文件 F2 跳转到下个错误 Shift + F2 上个错误代码(Code) Ctrl + O 查看重写的方法 Ctrl + I 查看实现的方法 Alt + Insert 生成构造方法、toString()等 Ctrl + Alt + T 生成代码块 Ctrl + J 插入 Live Template Alt + Shift + 上下箭头 将代码行上下移动 postfix Alt + Enter 不知道怎么写代码时重构(Refactor) Shift + F6 重命名 Extract运行(Run) Shift + F10/F9 运行/Debug 上次的程序 Alt + Shift + F10/F9 选择运行/Debug 程序 文件 Ctrl + C 光标指向文件时复制文件名 Ctrl + Shift + C 复制完整路径 Ctrl + F4 关闭当前编辑器窗口 Shift + Esc 隐藏当前面板Ctrl + F12 查看文件结构Ctrl + Alt + Shift + U 查看类图Ctrl + H 查看方法调用关系]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和接口]]></title>
    <url>%2F2018%2F12%2F09%2FeffectiveJava4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;类和接口是Java程序设计语言的核心，也是Java语言的基本抽象单元。本章的一些指导原则，可以帮助更好的利用这些语言元素，使设计出来的类和接口更将有用、健壮和灵活。 12. 使类和成员的可访问能力最小化&emsp;&emsp;一个设计良好的模块应当隐藏所有的实现细节，把API与实现清晰的隔离起来。然后，模块之间，只通过API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为封装。&emsp;&emsp;封装可以有效的解除一个系统中各模块之间的耦合关系，使得这些模块可以被独立的开发、测试、优化、使用、理解和修改。 四种访问级别 私有的(private)——只有在该类的内部才能访问 包级私有(default)——声明该成员的包内部的任何类都可以访问这个成员 保护的(protected)——子类和包内可访问 公有的(public)——任何地方都能访问 13. 支持非可变性&emsp;&emsp;一个非可变类是一个简单的类，它的实例不能被修改。每个实例中所包含的信息都必须在该实例被创建时就提供出来，并且在对象的整个生存期内固定不变。比如 String 类、原语类型的包装类、BigInteger、BigDecimal等。&emsp;&emsp;为使一个类成为非可变类，要遵循下面五条规则： 不要提供任何会修改对象的方法（也称为 mutator） 保证没有可被子类改写的方法使这个类称为 final 的 使所有域都是 final 的 使所有域称为私有的 保证对于任何可变组件的互斥访问如果该类具有指向可变对象的域，则必须保证客户不能获得这些指向这些对象的引用。不能用客户提供的对象引用来初始化这样的域 &emsp;&emsp;非可变类的优点： 非可变对象比较简单只有一个状态，即最初被创建时的状态 本质上是线程安全的，不需要同步 非可变对象为其他对象，提供了大量的构件 &emsp;&emsp;非可变类唯一的缺点是，对于每一个不同的值都要求一个单独的对象，创建这样的对象可能会代价很高。 14. 复合优于继承(类继承)&emsp;&emsp;一个子类依赖于其超类中特定功能的实现细节，继承打破了封装性。 &emsp;&emsp;假设我们需要查询 HashSet，看它自被创建以来曾经有多少个元素被加了进来，继承 HashSet 类的方法：1234567891011121314151617181920212223242526public class InstrumentedHashSet extends HashSet&#123; //加入的次数 private int addCount = 0; public InstrumentedHashSet()&#123; &#125; public InstrumentedHashSet(Collection c)&#123; super(c); &#125; public boolean add(Object o)&#123; addCount++; return super.add(o); &#125; public boolean addAll(Collection c)&#123; addCount += c.size(); return super.addAll(); &#125; public int getAddCount()&#123; return addCount; &#125;&#125; &emsp;&emsp;这个类看起来非常合理，实际上是错误的。在 HasgSet 的内部，addAll方法是基于 add 实现的，所以调用一次这个类的 addAll，实际加了两次 addCount。&emsp;&emsp;用 复合 (composition)：12345678910111213141516171819202122public class InstrumentedSet implements Set&#123; private final Set s; private int addCount = 0; public InstrumentedSet(Set s)&#123; this.s = s; &#125; public boolean add(Object o)&#123; addCount++; return s.add(o); &#125; public boolean addAll(Collection c)&#123; addCount += c.size(); return s.addAll(c); &#125; ... // 待实现的方法 ...&#125; &emsp;&emsp;每一个InstrumentedSet实例都把另一个Set实例包装起来了，所以InstrumentedSet被称作包装类，这是装饰者模式。 16. 接口优于抽象类&emsp;&emsp;使用抽象类比使用接口的优势：抽象类的演化(比如增加一个新的方法)比接口的演化容易得多， 18. 嵌套类的使用&emsp;&emsp;嵌套类是指被定义在另一个类内部的类，存在的目的只是为它的外围类服务。 静态成员类最简单地内部类，可以访问外围类的所有成员，包括私有的成员。如果成员类不要求访问外围实例，则声明为静态的。 非静态成员类非静态成员类的每一个实例都与外围类的一个外围实例紧密关联在一起 匿名类匿名类通常只实现其接口中或超类中的方法，不会声明任何新的方法。 局部类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Note</tag>
        <tag>Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招正式结束后的总结与感想]]></title>
    <url>%2F2018%2F12%2F07%2Flife1%2F</url>
    <content type="text"><![CDATA[更多…… 迷茫&emsp;&emsp;在大三下学期的那段时间里吧，突然发现自己保研有些悬，去找实习很不顺利，上的课程也感觉有些困难，没心思学。一度陷入了高一时那种失眠的状态，半夜爬起来甚至想从阳台跳下去，怀疑自己白读了十几年书。想搞信安竞赛确保推免，中途放弃了；想冲一下学习成绩，奈何操作系统和Windows安全，实在是没兴趣，也失败了。 准备&emsp;&emsp;于是下定决心找工作，选择了JavaWeb这个方向，在牛客网上做项目、看面经，在leetcode上刷题，甚至还买了久违的实体书。正式的准备应该是从七月开始的吧，中间也有过一些迷茫与懈怠，爸妈的鼓励和上海交大这几个字让我支撑了下来。期间回了一趟忠县，面对父母和亲朋好友的期待，也坚定了我的信心和勇气。 秋招&emsp;&emsp;回校之前那晚投了很多简历，第一次笔试时招行行用卡中心，第一次面试是在依图科技，感谢当时两个学长面试官的包容和优待，也是提升我的信心。也有一些面试体验不是很好，但也是帮助了我成长吧。&emsp;&emsp;在去小红书面试的路上，看见一对白发苍苍的夫妇，我想着会不会好人有好报，给他们让了座，他们慈祥的笑容和满怀的谢意让我真的庆幸做了这件事。也许是上天看见了吧，小红书的4轮面试都很简单，顺利通过。心中的巨石也算是落了地，不用担心失业了，准备着过一个舒适的中秋假期。&emsp;&emsp;中秋假期那三天，拿到了oppo的sp offer，15k 30w 着实让我激动了很久。从那以后也就开始放松了，放弃了很多机会。直到拼多多来学校宣讲，CTO的忽悠能力和高薪让我又豪情万丈，投简历、刷题、刷面经。两轮面试发挥的不好，本以为没戏了，都给爸妈说安心去成都了，也算是为秋招做一个完整的结尾，第一次和最后的面试都在金虹桥。没想hr突然打电话来hr面，最后给出了23k，40w+的offer，拼多多也在高速发展，实在没有拒绝的理由。 感想&emsp;&emsp;半年以前，永远不会相信自己能拿到这种数字的offer，也是一直给爸妈吹牛逼的40w，现在却实现了。选择真的和努力同样重要啊！如果当时选择了考研、或者选择了python、或者选择暑假去一个破地方实习，更久远一点，如果当时没选这个计算机相关的专业甚至没选择交大，现在不知会是怎样的情景和心情。缘分也是存在的吧，如果华为实习面试时没表现得那么傻比，可能就去华为实习然后白菜价转正了，如果拼多多宣讲时没有多问一句，就错过了。&emsp;&emsp;期间也发生了一些事，比如陈老师的意外。陈老师是我的伯乐，没有他也应该不会有我高考的成绩，这件事让我体会到了生命的脆弱和珍贵，珍惜身体的人！也希望他能好转起来。&emsp;&emsp;总而言之，一分耕耘，一分收获，加之正确的目标，成功并不遥远。从今天开始，我也在为工作做准备了，巩固并拓展专业知识，改善自己不擅长的方面（比如人际交往、沟通、ppt）。世俗的成功，我一定会达到的，然后再去探索人生的意义！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类的通用方法]]></title>
    <url>%2F2018%2F12%2F07%2FeffectiveJava3%2F</url>
    <content type="text"><![CDATA[Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。 7. 改写 equals 时的约定&emsp;&emsp;不改写equals的情况下，每个实例只与它自己相等，这种情况满足下列任何一个条件： 一个类的每一个实例本质上是唯一的代表了活动实体而不是值（value）的类，如 Thread。 不关心一个类是否提供“逻辑相等”的测试功能 超类已经改写了equals 一个类是私有的，或包级私有的，并且可以确定它的 equals 方法永远也不会调用。这种情形下，应该要改写equals方法，以免万一有一天它会被调用到：123public boolean equals(Object o)&#123; throw new UnsupportedOperationException();&#125; &emsp;&emsp;改写 equals 的约定： 自反性—— 一个对象等于其自身 对称从—— a.equals(b) 和 b.equals(a) 必须返回同样的结果 传递性—— a等于b，b等于c，则a等于c1234567891011121314public class ColorPoint extends Point&#123; private Color color; ... public boolean equals(Object o)&#123; if(!(o instanceof Point)) return false; //如果o是无色点，做忽略颜色的比较 if(!(o instanceof ColorPoint)) return o.equals(this); ColorPoint cp = (ColorPoint)o; return super.equals(o) &amp;&amp; cp.color = this.color; &#125;&#125; 这种方法提供了对称性，但牺牲了传递性，比如：123456789101112ColorPoint p1 = new ColorPoint(1, 1, blue);Point p2 = new Point(1,1);ColorPoint p3 = new ColorPoint(1, 1, red);``` 解决：（复合优于继承，tips14），不让 ColorPoint 继承 Point，而是在 ColorPoint 中加入一个私有的 Point 域```Javapublic class ColorPoint&#123; private Point point; private Color color; ...&#125; 一致性—— 如果两个对象相等，除非发生修改，否则必须始终保持相等 非空性—— 所有的对象都必须不等于 null 8. 改写 equals 时必须改写hashCode在每个改写了 equals 方法的类中，必须改写 hashCode 方法，使该类能与基于散列值(hash)的集合类一起正常运作。hashCode的预定： 如果一个对象的 equals 方法做比较所用到的信息没有被修改，那么调用 hashCode 方法必须返回同一整数 两个对象根据 equals 方法是相等的，那么hashCode方法产生同样的整数结果 不同对象的hashCode可以相同 一个好的hash函数 令int result = 17 或任意非零常数 对于对象每一个关键域 f（equals中用到的），完成以下步骤： a. 为该域计算int类型的的散列码c:i. boolean类型，c = f ? 0 : 1 ii. byte、short、char、int，c = (int)f iii. long类型，c = (int)(f ^ (f &gt;&gt;&gt; 32)) iv. float类型，c = Float.floatToIntBits(f) v. doubel类型，则先Double.doubleToLongBits(f)得到一个long类型的值 vi. 该域是一个对象引用，则递归调用 hashCode，如为null，则返回0 vii. 该域是一个数组，则把每一个元素当成单独的域处理 b. result = 37*result + c 返回result 测试 关键点 可以把冗余域排除在外 2.b中的乘法部分使得散列值依赖于域的顺序，这是合理的。例如不同字符排列的字符串是不同的。 缓存 hashCode1private volatile int hashCode = 0; 9. 总是要改写toString()提供一个好的 toString() 实现，可以使一个类使用起来更加愉快。当一个对象被传递给 println、字符串连接操作符(+)时，会自动调用toString()方法。 10. 谨慎改写 clone()Cloneable具有很多问题，推荐用拷贝构造函数来替代12public Person(Person person);public static Person newInstance(Person person); //静态工厂 &emsp;&emsp;一个拷贝构造函数可以带一个参数，它的类型可以是该类实现的一个适当的接口。例如，所有通用集合都实现了一个拷贝构造函数，它的参数类型时Collection或Map。假如有一个 LinkedList ，则可以 new ArrayList(l) 11. 考虑实现Comparable接口compareTo()方法与equals()方法的约定相似。当该对象小于、等于或大于指定对象时，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法比较，则抛出 ClassCastException 异常。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Object</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的创建和销毁]]></title>
    <url>%2F2018%2F12%2F07%2FeffectiveJava2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。 1. 考虑用静态工厂方法替代构造函数123public static Boolean valueOf(boolean b)&#123; return(b ? Boolean.TRUE : Boolean.FALSE);&#125; 好处 与构造函数不同，静态工厂方法拥有名字，可以使一个类更易与使用，代码更易读 每次被调用时，不要求非得创建一个对象把已经构造好的实例缓存起来，避免频繁创建相同的对象 可以返回一个原返回类型子类的对象 缺点 如果类不含有公有的或受保护的构造函数，就不能被子类化 与其他的静态方法没有任何区别在API文档中，不会像构造函数那样被明显标示出来。静态工作方法应遵守标准的命名规范，如 getInstance 2. 使用私有构造函数强化singleton属性&emsp;&emsp;singleton通常被用来指代那些本质上具有唯一性的系统组件，比如系统显示或文件系统。&emsp;&emsp;实现单例有两种方法，都要把构造函数保持为私有的，并且提供一个静态成员，以便允许客户能访问到该类唯一的实例。 1234567public class Singleton&#123; public static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125;&#125; 第二种提供了一个公有的静态方法，而不是公有的静态final域。1234567891011public class Singleton&#123; private static final Singleton INSTANCE = new Singleton(); private Singleton()&#123; ... &#125; public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125; 当序列化遇到单例时,就会出现问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求一个JVM中只有一个类对象的, 而现在通过反序列化,一个新的对象克隆了出来。加入readResolve方法：123private Object readResolve() throws ObjectStreamException&#123; return INSTANCE&#125; 尽管构造函数是私有的，但可序列化工具具有创建类实例的特殊访问权限—— 被实例化的类上的私有方法，称为readResolve（）。 3. 私有化构造函数使类不能实例化这样的工具类(utility class)不希望被实例化，让其包含单个显式的私有构造函数123456public class utilityClass&#123; private utilityClass&#123; &#125; ...&#125; 4. 避免创建重复的对象反面例子：1String s = new String("silly"); // DOn't DO THIS! 应当：1String s = "no longer silly"; 5. 消除过期的对象引用一个可能引起内存泄漏的例子（用数组实现栈）：123456789101112131415161718192021222324252627282930public class Stack&#123; private Object[] elements; private int size = 0; public Stack(int initialCapacity)&#123; this.size = new Object[initialCapacity]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; /** * 确保容量 **/ private void ensureCapacity()&#123; if(elements.length == size)&#123; Object[] oldElements = elements; elements = new Object[2 * size + 1]; System.arraycopy(oldElements, 0, elements, 0, size); &#125; &#125;&#125; 问题：如果一个栈先增长，再弹出，那么弹出的对象不会被当做垃圾回收。 修复：一旦对象引用已经过期，将其置空。pop()方法修改：12345678public Object pop()&#123; if(size == 0)&#123; throw ... &#125; Object result = element[--size]; element[size] = null; return result;&#125; 6. 避免使用终结函数(finalize)如果一个子类改写了终结函数，那么子类的终结函数必须手工调用超类的终结函数:1super.finalize();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EffectiveJava</tag>
        <tag>Object</tag>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
