<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yung&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinyuan97.me/"/>
  <updated>2019-06-17T02:43:49.714Z</updated>
  <id>https://qinyuan97.me/</id>
  
  <author>
    <name>Yung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>提高效率的工具和代码</title>
    <link href="https://qinyuan97.me/2019/04/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    <id>https://qinyuan97.me/2019/04/02/常用的类和代码/</id>
    <published>2019-04-02T09:05:17.036Z</published>
    <updated>2019-06-17T02:43:49.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;记录一些常用的提高效率的工具和代码</p><a id="more"></a><h2 id="常用的类"><a href="#常用的类" class="headerlink" title="常用的类"></a>常用的类</h2><h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.objects</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deepEquals</span><span class="params">(Object a, Object b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">toString</span><span class="params">(Object o, String nullDefault)</span></span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj, String message)</span></span>; <span class="comment">//检查是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(Object obj)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nonNull</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h4><p>Java8中引入了lambda，因此出现很多 filter(Objects::nonNull) 这样的写法，比filter(x -&gt; x != null) 更直观一些<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">List&lt;String&gt; list2 = list.stream()</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>Optional 类是一个可以为null的容器对象，不用显示进行空值检测，很好的解决了空指针异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line">Optional.ofNullable(request.getWord()).ifPresent(word::setWord);</span><br><span class="line">word.setWord(Optional.ofNullable(request.getWord()).orElse(<span class="string">""</span>));</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="常用的工具"><a href="#常用的工具" class="headerlink" title="常用的工具"></a>常用的工具</h2><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><ul><li>@NonNull: 作用于成员变量和参数</li><li>@RequiredArgsConstructor: 生成包含 final 和 @NonNull注解的成员变量的构造器</li><li>@NoArgsConstructor: 无参构造器</li><li>@AllArgsConstructor: 全参构造器</li><li><p>@Clearup: 自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如典型的IO流对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cleanup</span> InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br></pre></td></tr></table></figure></li><li><p>@SneakyThrows: 对受检异常进行捕捉并抛出</p></li><li><p>@EqualsAndHashCode: 默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。<br><br></p></li><li><p>@Data: 包含@ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合</p></li><li>@Log: 作用于类，创建一个log属性</li></ul><p><br></p><h2 id="常用的代码"><a href="#常用的代码" class="headerlink" title="常用的代码"></a>常用的代码</h2><h3 id="Java8-Stream"><a href="#Java8-Stream" class="headerlink" title="Java8 Stream"></a>Java8 Stream</h3><p>Stream方式将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等<br><code>stream of elements  -&gt; filter  -&gt; sorted -&gt; map -&gt; collect</code></p><ul><li><p>filter<br>设置条件过滤出元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤出空字符串</span></span><br><span class="line"><span class="keyword">int</span> nullCount = strings.stream().filter(Objects::isNull).count();</span><br></pre></td></tr></table></figure></li><li><p>map<br>map方法用于映射每个元素到对应的结果<br><br></p></li><li><p>forEach<br>迭代流中的每个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numList.stream().limit(<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>limit<br>用于获取指定数量的流<br><br></p></li><li>sorted<br>对流进行排序<br><br></li><li>Collectors<br>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。可用于返回列表或字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream().collect(Collectors.toList());</span><br><span class="line">stream().collect(Collectors.joining(<span class="string">","</span>));</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadText</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">read</span><span class="params">(InputStream in)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">            String line;</span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                result.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error in reading"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    <span class="comment">// do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inputStream 可以两种方式读取</span></span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(filePath));</span><br><span class="line"></span><br><span class="line">    InputStream in = ReadText.class.getResourceAsStream(fileName); <span class="comment">//文件放在 resources目录下，加 /</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;记录一些常用的提高效率的工具和代码&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://qinyuan97.me/categories/Java/"/>
    
    
      <category term="Note" scheme="https://qinyuan97.me/tags/Note/"/>
    
      <category term="Class" scheme="https://qinyuan97.me/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot实战系列</title>
    <link href="https://qinyuan97.me/2019/02/07/Spring%20Boot%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"/>
    <id>https://qinyuan97.me/2019/02/07/Spring Boot实战系列/</id>
    <published>2019-02-07T09:43:22.647Z</published>
    <updated>2019-02-07T09:56:41.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自<a href="https://www.codesheep.cn/" target="_blank" rel="noopener">CodeSheep程序羊</a><br><a id="more"></a></p><h2 id="数据库-缓存相关"><a href="#数据库-缓存相关" class="headerlink" title="数据库/缓存相关"></a>数据库/缓存相关</h2><ul><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_guava_cache" target="_blank" rel="noopener">Guava Cache本地缓存在 Spring Boot应用中的实践</a></li><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_evcache" target="_blank" rel="noopener">EVCache缓存在 Spring Boot中的实战</a></li><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_ehcache" target="_blank" rel="noopener">Spring Boot应用缓存实践之：Ehcache加持</a></li><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_mybatis_sqlserver" target="_blank" rel="noopener">Spring Boot集成 MyBatis和 SQL Server实践</a></li><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springboot_es_demo" target="_blank" rel="noopener">Elasticsearch搜索引擎在Spring Boot中的实践</a></li></ul><h2 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h2><ul><li><a href="https://www.codesheep.cn/2018/03/29/Boot%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">Spring Boot日志框架实践</a></li></ul><h2 id="应用监控相关"><a href="#应用监控相关" class="headerlink" title="应用监控相关"></a>应用监控相关</h2><ul><li><a href="https://www.codesheep.cn/2019/01/17/springbt-btrace/" target="_blank" rel="noopener">利用神器 BTrace 追踪线上 Spring Boot应用运行时信息</a></li><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_admin_server" target="_blank" rel="noopener">Spring Boot应用监控实战</a></li><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/spring_boot_admin2.0_demo" target="_blank" rel="noopener">Spring Boot Admin 2.0开箱体验</a></li></ul><h2 id="内部机制相关"><a href="#内部机制相关" class="headerlink" title="内部机制相关"></a>内部机制相关</h2><ul><li><a href="https://www.codesheep.cn/2018/07/30/at-SpringBootApplication-zhujie/" target="_blank" rel="noopener">SpringBoot 中 @SpringBootApplication注解背后的三体结构探秘</a></li><li><a href="https://www.codesheep.cn/2018/09/04/springboot-startup-process/" target="_blank" rel="noopener">SpringBoot 应用程序启动过程探秘</a></li><li><a href="https://www.codesheep.cn/2019/01/24/springbt-starter/" target="_blank" rel="noopener">如何自制一个Spring Boot Starter并推送到远端公服</a></li></ul><h2 id="实战经验相关"><a href="#实战经验相关" class="headerlink" title="实战经验相关"></a>实战经验相关</h2><ul><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_uid_generator" target="_blank" rel="noopener">Spring Boot工程集成全局唯一ID生成器 UidGenerator</a></li><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_vesta" target="_blank" rel="noopener">Spring Boot 工程集成全局唯一ID生成器 Vesta</a></li><li><a href="https://www.codesheep.cn/2018/04/09/SpringBoot%E4%BC%98%E9%9B%85%E7%BC%96%E7%A0%81%E4%B9%8B%EF%BC%9ALombok%E5%8A%A0%E6%8C%81/" target="_blank" rel="noopener">Spring Boot优雅编码之：Lombok加持</a></li><li><a href="https://www.codesheep.cn/2018/04/12/SpringBoot%E5%BA%94%E7%94%A8Docker%E5%8C%96/" target="_blank" rel="noopener">Spring Boot应用 Docker化</a></li><li><a href="https://www.codesheep.cn/2018/06/23/SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2%E5%8A%A0%E6%8C%81/" target="_blank" rel="noopener">Spring Boot热部署加持</a></li><li><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_watermark" target="_blank" rel="noopener">基于Spring Boot实现图片上传/加水印一把梭操作</a></li><li><a href="https://www.codesheep.cn/2018/06/10/%E4%BB%8ESpringBoot%E5%88%B0SpringMVC/" target="_blank" rel="noopener">从Spring Boot到 SpringMVC</a></li><li><a href="https://www.codesheep.cn/2018/11/01/springbt-hanlp/" target="_blank" rel="noopener">自然语言处理工具包 HanLP在 Spring Boot中的应用</a></li><li><a href="https://www.codesheep.cn/2018/06/05/SpringBoot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E4%BA%8E%E5%A4%96%E7%BD%AETomcat%E5%AE%B9%E5%99%A8/" target="_blank" rel="noopener">Spring Boot应用部署于外置Tomcat容器</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;https://www.codesheep.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CodeSheep程序羊&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="https://qinyuan97.me/categories/Web/"/>
    
    
      <category term="Spring" scheme="https://qinyuan97.me/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="https://qinyuan97.me/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>git的使用</title>
    <link href="https://qinyuan97.me/2019/01/04/gitNote/"/>
    <id>https://qinyuan97.me/2019/01/04/gitNote/</id>
    <published>2019-01-04T15:23:27.237Z</published>
    <updated>2019-04-08T04:59:56.813Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>git 的基本概念和操作</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><strong>git init</strong><br>在当前目录下初始化 git 仓库<br><br></li><li><strong>git status</strong><br>查看当前 git 仓库的状态<br><br></li><li><strong>git add</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add a.md 将文件提交到缓存区(防止误提交)</span><br><span class="line">git add . 把所有变化提交到暂存区，但不包括被删除的文件</span><br><span class="line">git add -u 仅监控已被 add 的文件，不会提交新文件</span><br><span class="line">git add -A 提交所有</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><strong>git commit</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;first commit&apos;  </span><br><span class="line">git commit -a -m &quot;commit&quot;  跳过add，自动把已跟踪过的文件暂存提交</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p><strong>git log</strong><br>查看所有的 commit 记录<br><br></p></li><li><p><strong>git branch</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch 查看当前分支情况</span><br><span class="line">git branch a 在当前分支下新建一个叫 a 的分支，此时内容完全一样</span><br><span class="line">git branch -d a 删除分支 a</span><br><span class="line">git branch -D a 可能还未合并，强制删除</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><strong>git checkout</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout a 切换到 a 分支下</span><br><span class="line">git checkout -b a 新建并切换到 a</span><br><span class="line">git checkout a.md 还原文件，只能撤销还未 add 进缓存区的文件</span><br><span class="line">git checkout -b local origin/master  从远程master新建本地仓库</span><br><span class="line"></span><br><span class="line">git checkout -- file 撤销暂存区中文件的修改</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><strong>git merge</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge a 在主分支下把分支 a 的代码合并过来</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><strong>git diff</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff 查看工作目录中文件和暂存区的差异</span><br><span class="line">git diff --cached 查看已暂存的将要添加到下次提交的内容</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p><strong>git remove</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached  从git中删除，但保留在磁盘上</span><br></pre></td></tr></table></figure></li><li><p><strong>git reset</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file  取消暂存</span><br></pre></td></tr></table></figure></li><li><p><strong>git tag</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0 在当前状态下新建一个标签</span><br><span class="line">git checkout v1.0 切换到 v.1.0 的代码状态</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><strong>push &amp; pull</strong><br>push：本地代码有更新，推到远程仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;pull：别人提交代码到远程仓库，把远程仓库的最新代码拉下来。一般 push 之前先 pull，不容易冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><p><br></p><ul><li><strong>提交代码</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@...git</span><br></pre></td></tr></table></figure></li></ul><p>将远程项目 clone 到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>提交代码到远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@...git</span><br></pre></td></tr></table></figure></p><p>将本地项目与 github 上的项目关联，origin 是远程仓库的名字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config —global user.name &quot;qinyuan&quot;</span><br><span class="line">git config —global user.email &quot;qinyuan1997@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>设置用户名和邮箱（去掉 -global 参数，在某一项目中使用特定的邮箱）<br><br></p><ul><li><strong>stash</strong><br>在暂时不能 commit 的情况下暂存代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></li></ul><p>把当前分支所有没有 commit 的代码都暂存起来，但是看不见任何改动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></p><p>查看暂存区记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure></p><p>还原暂存的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash drop 删除暂存区的这次 stash 记录</span><br><span class="line">git stash pop 还原并删除 stash 记录</span><br><span class="line">git stash clear 删除所有 stash 记录</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 的基本概念和操作&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://qinyuan97.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://qinyuan97.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>应用服务器变为集群后的Session问题</title>
    <link href="https://qinyuan97.me/2019/01/03/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E4%B8%BA%E9%9B%86%E7%BE%A4%E5%90%8E%E7%9A%84Session%E9%97%AE%E9%A2%98/"/>
    <id>https://qinyuan97.me/2019/01/03/应用服务器变为集群后的Session问题/</id>
    <published>2019-01-03T02:55:05.321Z</published>
    <updated>2019-01-03T03:38:59.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;HTTP 协议本身是无状态的，需要基于 HTTP 协议支持会话状态(Session State)的机制。这样的机制使 Web 服务器从多次单独的 HTTP 请求中看到会话，即知道哪些请求是来自哪些会话的。<br><a id="more"></a><br>&emsp;&emsp;具体实现方式：在会话开始时，分配一个唯一的会话标识(SessionId)，通过 Cookie 把这个标识告诉浏览器，以后每次请求的时候，浏览器都会带上这个标识来告诉 Web 服务器请求是属于哪个会话的。在 Web 服务器上，每个会话有独立的存储，保存不同会话的信息。如果遇到禁用 Cookie 的情况，一般就把这个会话标识放到URL的参数。<br>&emsp;&emsp;Session 问题：会话数据是保存在单机上的，要保证每一次请求都落在同一个服务器上。<br><br></p><h2 id="Session-Sticky"><a href="#Session-Sticky" class="headerlink" title="Session Sticky"></a>Session Sticky</h2><p>&emsp;&emsp;让负载均衡器能够根据每次请求的会话标识来进行请求转发。<br>&emsp;&emsp;这个方案非常简单，但有一些问题：</p><ul><li>如果一台 Web 服务器崩溃或者重启，这台机器上的会话数据就会丢失。</li><li>会话标识是应用层的信息，那么负载均衡器要将用一个会话的请求都保存到同一个 Web 服务器上的话，就需要进行应用层的解析，这个开销比第4层的交换要大。</li><li>负载均衡器变为了一个有状态的节点，要将会话保存到具体 Web 服务器的映射。和无状态的节点相比，内存消耗更大，容灾方面更麻烦。</li></ul><h2 id="Session-Replication"><a href="#Session-Replication" class="headerlink" title="Session Replication"></a>Session Replication</h2><p>&emsp;&emsp;Web 服务器之间增加会话数据的同步，保证不同 Web 服务器之间的 Session 书籍的一致。</p><ul><li>同步 Session 数据造成了网络带宽的开销。只要 Session 数据有变化，就需要将数据同步到所有其他机器上，机器数越多，同步带来的网络带宽开销就越大。</li><li>每台 Web 服务器都要保存所有的 Session 数据，如果整个集群的 Session 数很多，每天机器用于保存 Session 数据的内存占用严重。</li></ul><p>&emsp;&emsp;Session Replication 方案是靠应用容器开完成 Session 的复制，应用本身不用关心这个事情。但是，这个方案不适合集群机器数多的场景。</p><h2 id="Session-数据集中存储"><a href="#Session-数据集中存储" class="headerlink" title="Session 数据集中存储"></a>Session 数据集中存储</h2><p>&emsp;&emsp;把Session数据集中存储起来，然后不同 Web 服务器从同一个地方来获取 Session。<br>&emsp;&emsp;存在的问题：</p><ul><li>读写 Session 数据引入了网络操作，存在时延和不稳定性。</li><li>如果集中存储 Session 的机器或者集群有问题，就会影响应用。</li></ul><h2 id="Cookie-Based"><a href="#Cookie-Based" class="headerlink" title="Cookie Based"></a>Cookie Based</h2><p>&emsp;&emsp;把 Session 数据放在 Cookie 中，然后在 Web 服务器上从 Cookie 中生成对应的 Session 数据。好比每次都把自己的碗筷带在身上，这样去哪家饭店吃饭就介意随意选择。</p><ul><li>Cookie 长度的限制。</li><li>安全性问题</li><li>每次 HTTP 请求和响应都带有 Session 数据，对性能有影响。</li></ul><p><br><br>对于大型网站来说，Session Sticky 和 Session 集中存储是比较好的方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;HTTP 协议本身是无状态的，需要基于 HTTP 协议支持会话状态(Session State)的机制。这样的机制使 Web 服务器从多次单独的 HTTP 请求中看到会话，即知道哪些请求是来自哪些会话的。&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="https://qinyuan97.me/categories/Web/"/>
    
    
      <category term="Note" scheme="https://qinyuan97.me/tags/Note/"/>
    
      <category term="Session" scheme="https://qinyuan97.me/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA 使用技巧</title>
    <link href="https://qinyuan97.me/2018/12/15/IntelliJ%20IDEA/"/>
    <id>https://qinyuan97.me/2018/12/15/IntelliJ IDEA/</id>
    <published>2018-12-15T07:45:05.782Z</published>
    <updated>2018-12-15T11:43:43.499Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常见的 IntelliJ IDEA使用技巧整理</p><a id="more"></a><h1 id="编辑-Edit"><a href="#编辑-Edit" class="headerlink" title="编辑(Edit)"></a>编辑(Edit)</h1><ul><li>Ctrl + X 删除一行</li><li>Ctrl + W 扩大选择范围</li><li>Ctrl + D 复制一行</li><li>Ctrl + Shift + 左右箭头 扩大光标选择范围</li><li>Ctrl + Shift + U 转换大小写</li><li>Ctrl + Shift + V 调出剪切板<br><br></li><li>Ctrl + R 在文件中查找并替换</li><li>Ctrl + Shift + R 查找并替换</li><li>Ctrl + Shift + F 查找</li><li>Ctrl + Alt + Shift + J 光标选中所有符合的<br><br><h1 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h1></li><li>Ctrl + Shift + A  Find Action<br><br></li><li>Alt + 首字母 弹出对应选项</li><li>Alt + 1 跳转到 Project，之后 Ctrl+Shift+左右箭头 可移动分割线  F4 进入代码</li><li>Alt + 0 跳转到 Message  Ctrl + Shift + F4 关闭</li><li>Alt + 4 跳转到 Run</li><li>Alt + 6 跳转到 Todo</li><li>Alt + F12 跳转到终端<br><br></li><li>Ctrl + Q 显示文档</li><li>Ctrl + P 显示方法参数</li><li>Ctrl + E 最近文件</li><li>Ctrl + Shift + E 最近修改文件<br><br><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1></li><li>Alt + 上下箭头 方法之间跳转</li><li>Alt + 左右箭头 编辑区文件之间跳转</li><li>Ctrl + Alt + [ 或 ]  项目之间跳转<br><br></li><li>Ctrl + Shift + Backspace 跳转到上次编辑位置</li><li>Ctrl + Alt + 左右箭头   编辑位置跳转</li><li>Ctrl + G 跳转到行<br><br></li><li>Ctrl + N 查找类</li><li>Ctrl + Shift + N 查找文件</li><li>F2 跳转到下个错误</li><li>Shift + F2 上个错误<br><br><h1 id="代码-Code"><a href="#代码-Code" class="headerlink" title="代码(Code)"></a>代码(Code)</h1></li><li>Ctrl + O 查看重写的方法</li><li>Ctrl + I 查看实现的方法</li><li>Alt + Insert 生成构造方法、toString()等<br><br></li><li>Ctrl + Alt + T 生成代码块</li><li>Ctrl + J 插入 Live Template<br><br></li><li>Alt + Shift + 上下箭头 将代码行上下移动<br><br></li><li>postfix<br><br></li><li>Alt + Enter 不知道怎么写代码时<br><br><h1 id="重构-Refactor"><a href="#重构-Refactor" class="headerlink" title="重构(Refactor)"></a>重构(Refactor)</h1></li><li>Shift + F6 重命名</li><li>Extract<br><br><h1 id="运行-Run"><a href="#运行-Run" class="headerlink" title="运行(Run)"></a>运行(Run)</h1></li><li>Shift + F10/F9  运行/Debug 上次的程序</li><li>Alt + Shift + F10/F9 选择运行/Debug 程序</li></ul><p><br></p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul><li>Ctrl + C 光标指向文件时复制文件名</li><li>Ctrl + Shift + C 复制完整路径</li><li>Ctrl + F4 关闭当前编辑器窗口</li><li>Shift + Esc 隐藏当前面板<br><br><br>Ctrl + F12 查看文件结构<br>Ctrl + Alt + Shift + U 查看类图<br>Ctrl + H 查看方法调用关系</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的 IntelliJ IDEA使用技巧整理&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://qinyuan97.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDEA" scheme="https://qinyuan97.me/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>类和接口</title>
    <link href="https://qinyuan97.me/2018/12/09/effectiveJava4/"/>
    <id>https://qinyuan97.me/2018/12/09/effectiveJava4/</id>
    <published>2018-12-09T07:01:38.449Z</published>
    <updated>2018-12-09T15:17:07.283Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;类和接口是Java程序设计语言的核心，也是Java语言的基本抽象单元。本章的一些指导原则，可以帮助更好的利用这些语言元素，使设计出来的类和接口更将有用、健壮和灵活。</p><a id="more"></a><h2 id="12-使类和成员的可访问能力最小化"><a href="#12-使类和成员的可访问能力最小化" class="headerlink" title="12. 使类和成员的可访问能力最小化"></a><strong>12. 使类和成员的可访问能力最小化</strong></h2><p>&emsp;&emsp;一个设计良好的模块应当隐藏所有的实现细节，把API与实现清晰的隔离起来。然后，模块之间，只通过API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为封装。<br>&emsp;&emsp;封装可以有效的解除一个系统中各模块之间的耦合关系，使得这些模块可以被独立的开发、测试、优化、使用、理解和修改。<br><br></p><h3 id="四种访问级别"><a href="#四种访问级别" class="headerlink" title="四种访问级别"></a>四种访问级别</h3><ul><li><strong>私有的</strong>(private)——只有在该类的内部才能访问</li><li><strong>包级私有</strong>(default)——声明该成员的包内部的任何类都可以访问这个成员</li><li><strong>保护的</strong>(protected)——子类和包内可访问</li><li><strong>公有的</strong>(public)——任何地方都能访问<br><br></li></ul><h2 id="13-支持非可变性"><a href="#13-支持非可变性" class="headerlink" title="13. 支持非可变性"></a><strong>13. 支持非可变性</strong></h2><p>&emsp;&emsp;一个非可变类是一个简单的类，它的实例不能被修改。每个实例中所包含的信息都必须在该实例被创建时就提供出来，并且在对象的整个生存期内固定不变。比如 String 类、原语类型的包装类、BigInteger、BigDecimal等。<br><br><br>&emsp;&emsp;为使一个类成为非可变类，要遵循下面五条规则：</p><ul><li><strong>不要提供任何会修改对象的方法</strong>（也称为 mutator）</li><li><strong>保证没有可被子类改写的方法</strong><br>使这个类称为 final 的</li><li><strong>使所有域都是 final 的</strong></li><li><strong>使所有域称为私有的</strong></li><li><strong>保证对于任何可变组件的互斥访问</strong><br>如果该类具有指向可变对象的域，则必须保证客户不能获得这些指向这些对象的引用。不能用客户提供的对象引用来初始化这样的域<br><br></li></ul><p>&emsp;&emsp;非可变类的优点：</p><ul><li><strong>非可变对象比较简单</strong><br>只有一个状态，即最初被创建时的状态</li><li><strong>本质上是线程安全的，不需要同步</strong></li><li><strong>非可变对象为其他对象，提供了大量的构件</strong></li></ul><p>&emsp;&emsp;非可变类唯一的缺点是，对于每一个不同的值都要求一个单独的对象，创建这样的对象可能会代价很高。<br><br></p><h2 id="14-复合优于继承-类继承"><a href="#14-复合优于继承-类继承" class="headerlink" title="14. 复合优于继承(类继承)"></a><strong>14. 复合优于继承(类继承)</strong></h2><p>&emsp;&emsp;一个子类依赖于其超类中特定功能的实现细节，继承打破了<strong>封装性</strong>。</p><p>&emsp;&emsp;假设我们需要查询 HashSet，看它自被创建以来曾经有多少个元素被加了进来，继承 HashSet 类的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedHashSet</span> <span class="keyword">extends</span> <span class="title">HashSet</span></span>&#123;</span><br><span class="line">    <span class="comment">//加入的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstrumentedHashSet</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstrumentedHashSet</span><span class="params">(Collection c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span></span>&#123;</span><br><span class="line">        addCount += c.size();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAddCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个类看起来非常合理，实际上是错误的。在 HasgSet 的内部，addAll方法是基于 add 实现的，所以调用一次这个类的 addAll，实际加了两次 addCount。<br><br><br>&emsp;&emsp;用 <strong>复合</strong> (composition)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedSet</span> <span class="keyword">implements</span> <span class="title">Set</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstrumentedSet</span><span class="params">(Set s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        <span class="keyword">return</span> s.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span></span>&#123;</span><br><span class="line">        addCount += c.size();</span><br><span class="line">        <span class="keyword">return</span> s.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 待实现的方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;每一个<strong>InstrumentedSet</strong>实例都把另一个<strong>Set</strong>实例包装起来了，所以<strong>InstrumentedSet</strong>被称作包装类，这是装饰者模式。<br><br></p><h2 id="16-接口优于抽象类"><a href="#16-接口优于抽象类" class="headerlink" title="16. 接口优于抽象类"></a>16. 接口优于抽象类</h2><p>&emsp;&emsp;使用抽象类比使用接口的优势：抽象类的演化(比如增加一个新的方法)比接口的演化容易得多，<br><br></p><h2 id="18-嵌套类的使用"><a href="#18-嵌套类的使用" class="headerlink" title="18. 嵌套类的使用"></a>18. 嵌套类的使用</h2><p>&emsp;&emsp;嵌套类是指被定义在另一个类内部的类，存在的目的只是为它的外围类服务。</p><ul><li>静态成员类<br>最简单地内部类，可以访问外围类的所有成员，包括私有的成员。如果成员类不要求访问外围实例，则声明为静态的。</li><li>非静态成员类<br>非静态成员类的每一个实例都与外围类的一个外围实例紧密关联在一起</li><li>匿名类<br>匿名类通常只实现其接口中或超类中的方法，不会声明任何新的方法。</li><li>局部类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;类和接口是Java程序设计语言的核心，也是Java语言的基本抽象单元。本章的一些指导原则，可以帮助更好的利用这些语言元素，使设计出来的类和接口更将有用、健壮和灵活。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://qinyuan97.me/categories/Java/"/>
    
    
      <category term="EffectiveJava" scheme="https://qinyuan97.me/tags/EffectiveJava/"/>
    
      <category term="Note" scheme="https://qinyuan97.me/tags/Note/"/>
    
      <category term="Interface" scheme="https://qinyuan97.me/tags/Interface/"/>
    
  </entry>
  
  <entry>
    <title>秋招正式结束后的总结与感想</title>
    <link href="https://qinyuan97.me/2018/12/07/life1/"/>
    <id>https://qinyuan97.me/2018/12/07/life1/</id>
    <published>2018-12-07T14:41:17.199Z</published>
    <updated>2019-06-17T03:00:47.865Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>更多……<br><a id="more"></a></p><h2 id="迷茫"><a href="#迷茫" class="headerlink" title="迷茫"></a>迷茫</h2><p>&emsp;&emsp;在大三下学期的那段时间里吧，突然发现自己保研有些悬，去找实习很不顺利，上的课程也感觉有些困难，没心思学。一度陷入了高一时那种失眠的状态，半夜爬起来甚至想从阳台跳下去，怀疑自己白读了十几年书。想搞信安竞赛确保推免，中途放弃了；想冲一下学习成绩，奈何操作系统和Windows安全，实在是没兴趣，也失败了。<br><br></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>&emsp;&emsp;于是下定决心找工作，选择了JavaWeb这个方向，在牛客网上做项目、看面经，在leetcode上刷题，甚至还买了久违的实体书。正式的准备应该是从七月开始的吧，中间也有过一些迷茫与懈怠，爸妈的鼓励和上海交大这几个字让我支撑了下来。期间回了一趟忠县，面对父母和亲朋好友的期待，也坚定了我的信心和勇气。<br><br></p><h2 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h2><p>&emsp;&emsp;回校之前那晚投了很多简历，第一次笔试时招行行用卡中心，第一次面试是在依图科技，感谢当时两个学长面试官的包容和优待，也是提升我的信心。也有一些面试体验不是很好，但也是帮助了我成长吧。<br>&emsp;&emsp;在去小红书面试的路上，看见一对白发苍苍的夫妇，我想着会不会好人有好报，给他们让了座，他们慈祥的笑容和满怀的谢意让我真的庆幸做了这件事。也许是上天看见了吧，小红书的4轮面试都很简单，顺利通过。心中的巨石也算是落了地，不用担心失业了，准备着过一个舒适的中秋假期。<br>&emsp;&emsp;中秋假期那三天，拿到了oppo的sp offer，15k 30w 着实让我激动了很久。从那以后也就开始放松了，放弃了很多机会。直到拼多多来学校宣讲，CTO的忽悠能力和高薪让我又豪情万丈，投简历、刷题、刷面经。两轮面试发挥的不好，本以为没戏了，都给爸妈说安心去成都了，也算是为秋招做一个完整的结尾，第一次和最后的面试都在金虹桥。没想hr突然打电话来hr面，最后给出了23k，40w+的offer，拼多多也在高速发展，实在没有拒绝的理由。<br><br><br><img src="https://i.loli.net/2018/12/09/5c0cb70d94f1e.jpg" alt="timg.jpg"></p><p><br></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>&emsp;&emsp;半年以前，永远不会相信自己能拿到这种数字的offer，也是一直给爸妈吹牛逼的40w，现在却实现了。选择真的和努力同样重要啊！如果当时选择了考研、或者选择了python、或者选择暑假去一个破地方实习，更久远一点，如果当时没选这个计算机相关的专业甚至没选择交大，现在不知会是怎样的情景和心情。缘分也是存在的吧，如果华为实习面试时没表现得那么傻比，可能就去华为实习然后白菜价转正了，如果拼多多宣讲时没有多问一句，就错过了。<br>&emsp;&emsp;期间也发生了一些事，比如陈老师的意外。陈老师是我的伯乐，没有他也应该不会有我高考的成绩，这件事让我体会到了生命的脆弱和珍贵，珍惜身体的人！也希望他能好转起来。<br>&emsp;&emsp;总而言之，一分耕耘，一分收获，加之正确的目标，成功并不遥远。从今天开始，我也在为工作做准备了，巩固并拓展专业知识，改善自己不擅长的方面（比如人际交往、沟通、ppt）。世俗的成功，我一定会达到的，然后再去探索人生的意义！<br><br><br><img src="https://i.loli.net/2018/12/09/5c0cb91fd797a.jpg" alt="waitan_yejing-006.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更多……&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="https://qinyuan97.me/categories/life/"/>
    
    
      <category term="随笔" scheme="https://qinyuan97.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Object类的通用方法</title>
    <link href="https://qinyuan97.me/2018/12/07/effectiveJava3/"/>
    <id>https://qinyuan97.me/2018/12/07/effectiveJava3/</id>
    <published>2018-12-07T13:57:33.503Z</published>
    <updated>2018-12-09T15:17:48.704Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。</p><a id="more"></a><h2 id="7-改写-equals-时的约定"><a href="#7-改写-equals-时的约定" class="headerlink" title="7. 改写 equals 时的约定"></a><strong>7. 改写 equals 时的约定</strong></h2><p>&emsp;&emsp;不改写equals的情况下，每个实例只与它自己相等，这种情况满足下列任何一个条件：</p><ul><li>一个类的每一个实例本质上是唯一的<br>代表了活动实体而不是值（value）的类，如 Thread。</li><li>不关心一个类是否提供“逻辑相等”的测试功能</li><li>超类已经改写了equals</li><li>一个类是私有的，或包级私有的，并且可以确定它的 equals 方法永远也不会调用。<br>这种情形下，应该要改写equals方法，以免万一有一天它会被调用到：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br><br>&emsp;&emsp;改写 equals 的约定：</p><ul><li><strong>自反性</strong>—— 一个对象等于其自身</li><li><strong>对称从</strong>—— a.equals(b) 和 b.equals(a) 必须返回同样的结果</li><li><strong>传递性</strong>—— a等于b，b等于c，则a等于c<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果o是无色点，做忽略颜色的比较</span></span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        ColorPoint cp = (ColorPoint)o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; cp.color = <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这种方法提供了对称性，但牺牲了传递性，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint p1 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">1</span>, blue);</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">ColorPoint p3 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">1</span>, red);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">解决：（复合优于继承，tips14），不让 ColorPoint 继承 Point，而是在 ColorPoint 中加入一个私有的 Point 域</span><br><span class="line">```Java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point point;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>一致性</strong>—— 如果两个对象相等，除非发生修改，否则必须始终保持相等</li><li><strong>非空性</strong>—— 所有的对象都必须不等于 null</li></ul><p><br></p><h2 id="8-改写-equals-时必须改写hashCode"><a href="#8-改写-equals-时必须改写hashCode" class="headerlink" title="8. 改写 equals 时必须改写hashCode"></a><strong>8. 改写 equals 时必须改写hashCode</strong></h2><p>在每个改写了 equals 方法的类中，必须改写 hashCode 方法，使该类能与基于散列值(hash)的集合类一起正常运作。hashCode的预定：</p><ul><li>如果一个对象的 equals 方法做比较所用到的信息没有被修改，那么调用 hashCode 方法必须返回同一整数</li><li>两个对象根据 equals 方法是相等的，那么hashCode方法产生同样的整数结果</li><li>不同对象的hashCode可以相同</li></ul><h3 id="一个好的hash函数"><a href="#一个好的hash函数" class="headerlink" title="一个好的hash函数"></a>一个好的hash函数</h3><ol><li>令int result = 17     或任意非零常数</li><li>对于对象每一个关键域 f（equals中用到的），完成以下步骤：<br> a. 为该域计算int类型的的散列码c:<pre><code>i. boolean类型，c =  f ? 0 : 1ii. byte、short、char、int，c = (int)fiii. long类型，c = (int)(f ^ (f &gt;&gt;&gt; 32))iv. float类型，c = Float.floatToIntBits(f)v. doubel类型，则先Double.doubleToLongBits(f)得到一个long类型的值vi. 该域是一个对象引用，则递归调用 hashCode，如为null，则返回0vii. 该域是一个数组，则把每一个元素当成单独的域处理</code></pre> b. result = 37*result + c</li><li>返回result</li><li>测试</li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>可以把冗余域排除在外</li><li>2.b中的乘法部分使得散列值依赖于域的顺序，这是合理的。例如不同字符排列的字符串是不同的。</li><li>缓存 hashCode<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="9-总是要改写toString"><a href="#9-总是要改写toString" class="headerlink" title="9. 总是要改写toString()"></a><strong>9. 总是要改写toString()</strong></h2><p>提供一个好的 toString() 实现，可以使一个类使用起来更加愉快。当一个对象被传递给 println、字符串连接操作符(+)时，会自动调用toString()方法。</p><p><br></p><h2 id="10-谨慎改写-clone"><a href="#10-谨慎改写-clone" class="headerlink" title="10. 谨慎改写 clone()"></a><strong>10. 谨慎改写 clone()</strong></h2><p>Cloneable具有很多问题，推荐用拷贝构造函数来替代<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Person person)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">newInstance</span><span class="params">(Person person)</span></span>; <span class="comment">//静态工厂</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;一个拷贝构造函数可以带一个参数，它的类型可以是该类实现的一个适当的接口。例如，所有通用集合都实现了一个拷贝构造函数，它的参数类型时Collection或Map。假如有一个 LinkedList ，则可以 new ArrayList(l)</p><p><br></p><h2 id="11-考虑实现Comparable接口"><a href="#11-考虑实现Comparable接口" class="headerlink" title="11. 考虑实现Comparable接口"></a><strong>11. 考虑实现Comparable接口</strong></h2><p>compareTo()方法与equals()方法的约定相似。<br>当该对象小于、等于或大于指定对象时，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法比较，则抛出 ClassCastException 异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://qinyuan97.me/categories/Java/"/>
    
    
      <category term="EffectiveJava" scheme="https://qinyuan97.me/tags/EffectiveJava/"/>
    
      <category term="Object" scheme="https://qinyuan97.me/tags/Object/"/>
    
      <category term="Note" scheme="https://qinyuan97.me/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>对象的创建和销毁</title>
    <link href="https://qinyuan97.me/2018/12/07/effectiveJava2/"/>
    <id>https://qinyuan97.me/2018/12/07/effectiveJava2/</id>
    <published>2018-12-07T08:22:45.251Z</published>
    <updated>2018-12-09T15:17:39.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。</p><a id="more"></a><h2 id="1-考虑用静态工厂方法替代构造函数"><a href="#1-考虑用静态工厂方法替代构造函数" class="headerlink" title="1. 考虑用静态工厂方法替代构造函数"></a><strong>1. 考虑用静态工厂方法替代构造函数</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(b ? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a><strong>好处</strong></h3><ul><li>与构造函数不同，静态工厂方法拥有名字，可以使一个类更易与使用，代码更易读</li><li>每次被调用时，不要求非得创建一个对象<br>把已经构造好的实例缓存起来，避免频繁创建相同的对象</li><li>可以返回一个原返回类型子类的对象</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul><li>如果类不含有公有的或受保护的构造函数，就不能被子类化</li><li>与其他的静态方法没有任何区别<br>在API文档中，不会像构造函数那样被明显标示出来。静态工作方法应遵守标准的命名规范，如 getInstance</li></ul><p><br></p><h2 id="2-使用私有构造函数强化singleton属性"><a href="#2-使用私有构造函数强化singleton属性" class="headerlink" title="2. 使用私有构造函数强化singleton属性"></a><strong>2. 使用私有构造函数强化singleton属性</strong></h2><p>&emsp;&emsp;singleton通常被用来指代那些本质上具有唯一性的系统组件，比如系统显示或文件系统。<br>&emsp;&emsp;实现单例有两种方法，都要把构造函数保持为私有的，并且提供一个静态成员，以便允许客户能访问到该类唯一的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种提供了一个公有的静态方法，而不是公有的静态final域。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当序列化遇到单例时,就会出现问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求一个JVM中只有一个类对象的, 而现在通过反序列化,一个新的对象克隆了出来。<br>加入readResolve方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尽管构造函数是私有的，但可序列化工具具有创建类实例的特殊访问权限—— 被实例化的类上的私有方法，称为readResolve（）。</p><p><br></p><h2 id="3-私有化构造函数使类不能实例化"><a href="#3-私有化构造函数使类不能实例化" class="headerlink" title="3. 私有化构造函数使类不能实例化"></a><strong>3. 私有化构造函数使类不能实例化</strong></h2><p>这样的工具类(utility class)不希望被实例化，让其包含单个显式的私有构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">utilityClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> utilityClass&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="4-避免创建重复的对象"><a href="#4-避免创建重复的对象" class="headerlink" title="4. 避免创建重复的对象"></a><strong>4. 避免创建重复的对象</strong></h2><p>反面例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"silly"</span>); <span class="comment">// DOn't DO THIS!</span></span><br></pre></td></tr></table></figure></p><p>应当：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"no longer silly"</span>;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="5-消除过期的对象引用"><a href="#5-消除过期的对象引用" class="headerlink" title="5. 消除过期的对象引用"></a><strong>5. 消除过期的对象引用</strong></h2><p>一个可能引起内存泄漏的例子（用数组实现栈）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 确保容量</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size)&#123;</span><br><span class="line">            Object[] oldElements = elements;</span><br><span class="line">            elements = <span class="keyword">new</span> Object[<span class="number">2</span> * size + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(oldElements, <span class="number">0</span>, elements, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题：如果一个栈先增长，再弹出，那么弹出的对象不会被当做垃圾回收。</p><p>修复：一旦对象引用已经过期，将其置空。pop()方法修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">    Object result = element[--size];</span><br><span class="line">    element[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="6-避免使用终结函数-finalize"><a href="#6-避免使用终结函数-finalize" class="headerlink" title="6. 避免使用终结函数(finalize)"></a><strong>6. 避免使用终结函数(finalize)</strong></h2><p>如果一个子类改写了终结函数，那么子类的终结函数必须手工调用超类的终结函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.finalize();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://qinyuan97.me/categories/Java/"/>
    
    
      <category term="EffectiveJava" scheme="https://qinyuan97.me/tags/EffectiveJava/"/>
    
      <category term="Object" scheme="https://qinyuan97.me/tags/Object/"/>
    
      <category term="Note" scheme="https://qinyuan97.me/tags/Note/"/>
    
  </entry>
  
</feed>
