<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yung&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinyuan97.me/"/>
  <updated>2018-12-09T06:36:13.389Z</updated>
  <id>https://qinyuan97.me/</id>
  
  <author>
    <name>Yung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>秋招正式结束后的总结与感想</title>
    <link href="https://qinyuan97.me/2018/12/07/life1/"/>
    <id>https://qinyuan97.me/2018/12/07/life1/</id>
    <published>2018-12-07T14:41:17.199Z</published>
    <updated>2018-12-09T06:36:13.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>更多……<br><a id="more"></a></p><h2 id="迷茫"><a href="#迷茫" class="headerlink" title="迷茫"></a>迷茫</h2><p>&emsp;&emsp;在大三下学期的那段时间里吧，突然发现自己保研有些悬，去找实习很不顺利，上的课程也感觉有些困难，没心思学。一度陷入了高一时那种失眠的状态，半夜爬起来甚至想从阳台跳下去，怀疑自己白读了十几年书。想搞信安竞赛确保推免，中途放弃了；想冲一下学习成绩，奈何操作系统和Windows安全，实在是没兴趣，也失败了。<br><br></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>&emsp;&emsp;于是下定决心找工作，选择了JavaWeb这个方向，在牛客网上做项目、看面经，在leetcode上刷题，甚至还买了久违的实体书。正式的准备应该是从七月开始的吧，中间也有过一些迷茫与懈怠，爸妈的鼓励和上海交大这几个字让我支撑了下来。期间回了一趟忠县，面对父母和亲朋好友的期待，也坚定了我的信心和勇气。<br><br></p><h2 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h2><p>&emsp;&emsp;回校之前那晚投了很多简历，第一次笔试时招行行用卡中心，第一次面试是在依图科技，感谢当时两个学长面试官的包容和优待，也是提升我的信心。也有一些面试体验不是很好，但也是帮助了我成长吧。<br>&emsp;&emsp;在去小红书面试的路上，看见一对白发苍苍的夫妇，我想着会不会好人有好报，给他们让了座，他们慈祥的笑容和满怀的谢意让我真的庆幸做了这件事。也许是上天看见了吧，小红书的4轮面试都很简单，顺利通过。心中的巨石也算是落了地，不用担心失业了，准备着过一个舒适的中秋假期。<br>&emsp;&emsp;中秋假期那三天，拿到了oppo的sp offer，15k 30w 着实让我激动了很久。从那以后也就开始放松了，放弃了很多机会。直到拼多多来学校宣讲，CTO的忽悠能力和高薪让我又豪情万丈，投简历、刷题、刷面经。两轮面试发挥的不好，本以为没戏了，都给爸妈说安心去成都了，也算是为秋招做一个完整的结尾，第一次和最后的面试都在金虹桥。没想hr突然打电话来hr面，最后给出了23k，40w+的offer，拼多多也在高速发展，实在没有拒绝的理由。<br><br><br><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/<a href=https://i.loli.net/2018/12/09/5c0cb70d94f1e.jpg>https://i.loli.net/2018/12/09/5c0cb70d94f1e.jpg</a>" class="full-image" alt="title=’金虹桥国际中心’}</p> <p><br></p> <h2 id=感想><a href=#感想 class=headerlink title=感想></a>感想</h2><p>&emsp;&emsp;半年以前，永远不会相信自己能拿到这种数字的offer，也是一直给爸妈吹牛逼的40w，现在却实现了。选择真的和努力同样重要啊！如果当时选择了考研、或者选择了python、或者选择暑假去一个破地方实习，更久远一点，如果当时没选这个计算机相关的专业甚至没选择交大，现在不知会是怎样的情景和心情。缘分也是存在的吧，如果华为实习面试时没表现得那么傻比，可能就去华为实习然后白菜价转正了，如果拼多多宣讲时没有多问一句，就错过了。<br>&emsp;&emsp;期间也发生了一些事，比如陈老师的意外。陈老师是我的伯乐，没有他也应该不会有我高考的成绩，这件事让我体会到了生命的脆弱和珍贵，珍惜身体的人！也希望他能好转起来。<br>&emsp;&emsp;总而言之，一分耕耘，一分收获，加之正确的目标，成功并不遥远。从今天开始，我也在为工作做准备了，巩固并拓展专业知识，改善自己不擅长的方面（比如人际交往、沟通、ppt）。世俗的成功，我一定会达到的，然后再去探索人生的意义！<br><br></p>"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更多……&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="https://qinyuan97.me/categories/life/"/>
    
    
      <category term="随笔" scheme="https://qinyuan97.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Object类的通用方法</title>
    <link href="https://qinyuan97.me/2018/12/07/effectiveJava3/"/>
    <id>https://qinyuan97.me/2018/12/07/effectiveJava3/</id>
    <published>2018-12-07T13:57:33.503Z</published>
    <updated>2018-12-07T13:58:52.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。</p><a id="more"></a><h2 id="7-改写-equals-时的约定"><a href="#7-改写-equals-时的约定" class="headerlink" title="7. 改写 equals 时的约定"></a><strong>7. 改写 equals 时的约定</strong></h2><p>&emsp;&emsp;不改写equals的情况下，每个实例只与它自己相等，这种情况满足下列任何一个条件：</p><ul><li>一个类的每一个实例本质上是唯一的<br>代表了活动实体而不是值（value）的类，如 Thread。</li><li>不关心一个类是否提供“逻辑相等”的测试功能</li><li>超类已经改写了equals</li><li>一个类是私有的，或包级私有的，并且可以确定它的 equals 方法永远也不会调用。<br>这种情形下，应该要改写equals方法，以免万一有一天它会被调用到：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br><br>&emsp;&emsp;改写 equals 的约定：</p><ul><li><strong>自反性</strong>—— 一个对象等于其自身</li><li><strong>对称从</strong>—— a.equals(b) 和 b.equals(a) 必须返回同样的结果</li><li><strong>传递性</strong>—— a等于b，b等于c，则a等于c<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果o是无色点，做忽略颜色的比较</span></span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        ColorPoint cp = (ColorPoint)o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; cp.color = <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这种方法提供了对称性，但牺牲了传递性，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint p1 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">1</span>, blue);</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">ColorPoint p3 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">1</span>, red);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">解决：（复合优于继承，tips14），不让 ColorPoint 继承 Point，而是在 ColorPoint 中加入一个私有的 Point 域</span><br><span class="line">```Java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point point;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><strong>一致性</strong>—— 如果两个对象相等，除非发生修改，否则必须始终保持相等</li><li><strong>非空性</strong>—— 所有的对象都必须不等于 null</li></ul><p><br></p><h2 id="8-改写-equals-时必须改写hashCode"><a href="#8-改写-equals-时必须改写hashCode" class="headerlink" title="8. 改写 equals 时必须改写hashCode"></a><strong>8. 改写 equals 时必须改写hashCode</strong></h2><p>在每个改写了 equals 方法的类中，必须改写 hashCode 方法，使该类能与基于散列值(hash)的集合类一起正常运作。hashCode的预定：</p><ul><li>如果一个对象的 equals 方法做比较所用到的信息没有被修改，那么调用 hashCode 方法必须返回同一整数</li><li>两个对象根据 equals 方法是相等的，那么hashCode方法产生同样的整数结果</li><li>不同对象的hashCode可以相同</li></ul><h3 id="一个好的hash函数"><a href="#一个好的hash函数" class="headerlink" title="一个好的hash函数"></a>一个好的hash函数</h3><ol><li>令int result = 17     或任意非零常数</li><li>对于对象每一个关键域 f（equals中用到的），完成以下步骤：<br> a. 为该域计算int类型的的散列码c:<pre><code>&amp;emsp;&amp;emsp;i. boolean类型，c =  f ? 0 : 1&amp;emsp;&amp;emsp;ii. byte、short、char、int，c = (int)f&amp;emsp;&amp;emsp;iii. long类型，c = (int)(f ^ (f &gt;&gt;&gt; 32))&amp;emsp;&amp;emsp;iv. float类型，c = Float.floatToIntBits(f)&amp;emsp;&amp;emsp;v. doubel类型，则先Double.doubleToLongBits(f)得到一个long类型的值&amp;emsp;&amp;emsp;vi. 该域是一个对象引用，则递归调用 hashCode，如为null，则返回0&amp;emsp;&amp;emsp;vii. 该域是一个数组，则把每一个元素当成单独的域处理</code></pre> b. result = 37*result + c</li><li>返回result</li><li>测试</li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>可以把冗余域排除在外</li><li>2.b中的乘法部分使得散列值依赖于域的顺序，这是合理的。例如不同字符排列的字符串是不同的。</li><li>缓存 hashCode<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="9-总是要改写toString"><a href="#9-总是要改写toString" class="headerlink" title="9. 总是要改写toString()"></a><strong>9. 总是要改写toString()</strong></h2><p>提供一个好的 toString() 实现，可以使一个类使用起来更加愉快。当一个对象被传递给 println、字符串连接操作符(+)时，会自动调用toString()方法。</p><p><br></p><h2 id="10-谨慎改写-clone"><a href="#10-谨慎改写-clone" class="headerlink" title="10. 谨慎改写 clone()"></a><strong>10. 谨慎改写 clone()</strong></h2><p>Cloneable具有很多问题，推荐用拷贝构造函数来替代<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Person person)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">newInstance</span><span class="params">(Person person)</span></span>; <span class="comment">//静态工厂</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;一个拷贝构造函数可以带一个参数，它的类型可以是该类实现的一个适当的接口。例如，所有通用集合都实现了一个拷贝构造函数，它的参数类型时Collection或Map。假如有一个 LinkedList ，则可以 new ArrayList(l)</p><p><br></p><h2 id="11-考虑实现Comparable接口"><a href="#11-考虑实现Comparable接口" class="headerlink" title="11. 考虑实现Comparable接口"></a><strong>11. 考虑实现Comparable接口</strong></h2><p>compareTo()方法与equals()方法的约定相似。<br>当该对象小于、等于或大于指定对象时，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法比较，则抛出 ClassCastException 异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object是一个具体类，但是设计它主要是为了扩展，它的所有非 final 方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://qinyuan97.me/categories/Java/"/>
    
    
      <category term="EffectiveJava" scheme="https://qinyuan97.me/tags/EffectiveJava/"/>
    
      <category term="Object" scheme="https://qinyuan97.me/tags/Object/"/>
    
      <category term="Note" scheme="https://qinyuan97.me/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>对象的创建和销毁</title>
    <link href="https://qinyuan97.me/2018/12/07/effectiveJava2/"/>
    <id>https://qinyuan97.me/2018/12/07/effectiveJava2/</id>
    <published>2018-12-07T08:22:45.251Z</published>
    <updated>2018-12-07T13:59:01.764Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。</p><a id="more"></a><h2 id="1-考虑用静态工厂方法替代构造函数"><a href="#1-考虑用静态工厂方法替代构造函数" class="headerlink" title="1. 考虑用静态工厂方法替代构造函数"></a><strong>1. 考虑用静态工厂方法替代构造函数</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(b ? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a><strong>好处</strong></h3><ul><li>与构造函数不同，静态工厂方法拥有名字，可以使一个类更易与使用，代码更易读</li><li>每次被调用时，不要求非得创建一个对象<br>把已经构造好的实例缓存起来，避免频繁创建相同的对象</li><li>可以返回一个原返回类型子类的对象</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul><li>如果类不含有公有的或受保护的构造函数，就不能被子类化</li><li>与其他的静态方法没有任何区别<br>在API文档中，不会像构造函数那样被明显标示出来。静态工作方法应遵守标准的命名规范，如 getInstance</li></ul><p><br></p><h2 id="2-使用私有构造函数强化singleton属性"><a href="#2-使用私有构造函数强化singleton属性" class="headerlink" title="2. 使用私有构造函数强化singleton属性"></a><strong>2. 使用私有构造函数强化singleton属性</strong></h2><p>&emsp;&emsp;singleton通常被用来指代那些本质上具有唯一性的系统组件，比如系统显示或文件系统。<br>&emsp;&emsp;实现单例有两种方法，都要把构造函数保持为私有的，并且提供一个静态成员，以便允许客户能访问到该类唯一的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种提供了一个公有的静态方法，而不是公有的静态final域。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当序列化遇到单例时,就会出现问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求一个JVM中只有一个类对象的, 而现在通过反序列化,一个新的对象克隆了出来。<br>加入readResolve方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尽管构造函数是私有的，但可序列化工具具有创建类实例的特殊访问权限—— 被实例化的类上的私有方法，称为readResolve（）。</p><p><br></p><h2 id="3-私有化构造函数使类不能实例化"><a href="#3-私有化构造函数使类不能实例化" class="headerlink" title="3. 私有化构造函数使类不能实例化"></a><strong>3. 私有化构造函数使类不能实例化</strong></h2><p>这样的工具类(utility class)不希望被实例化，让其包含单个显式的私有构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">utilityClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> utilityClass&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="4-避免创建重复的对象"><a href="#4-避免创建重复的对象" class="headerlink" title="4. 避免创建重复的对象"></a><strong>4. 避免创建重复的对象</strong></h2><p>反面例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"silly"</span>); <span class="comment">// DOn't DO THIS!</span></span><br></pre></td></tr></table></figure></p><p>应当：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"no longer silly"</span>;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="5-消除过期的对象引用"><a href="#5-消除过期的对象引用" class="headerlink" title="5. 消除过期的对象引用"></a><strong>5. 消除过期的对象引用</strong></h2><p>一个可能引起内存泄漏的例子（用数组实现栈）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 确保容量</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size)&#123;</span><br><span class="line">            Object[] oldElements = elements;</span><br><span class="line">            elements = <span class="keyword">new</span> Object[<span class="number">2</span> * size + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(oldElements, <span class="number">0</span>, elements, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题：如果一个栈先增长，再弹出，那么弹出的对象不会被当做垃圾回收。</p><p>修复：一旦对象引用已经过期，将其置空。pop()方法修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">    Object result = element[--size];</span><br><span class="line">    element[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="6-避免使用终结函数-finalize"><a href="#6-避免使用终结函数-finalize" class="headerlink" title="6. 避免使用终结函数(finalize)"></a><strong>6. 避免使用终结函数(finalize)</strong></h2><p>如果一个子类改写了终结函数，那么子类的终结函数必须手工调用超类的终结函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.finalize();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://qinyuan97.me/categories/Java/"/>
    
    
      <category term="EffectiveJava" scheme="https://qinyuan97.me/tags/EffectiveJava/"/>
    
      <category term="Object" scheme="https://qinyuan97.me/tags/Object/"/>
    
      <category term="Note" scheme="https://qinyuan97.me/tags/Note/"/>
    
  </entry>
  
</feed>
