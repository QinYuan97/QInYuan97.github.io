<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yung&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinyuan97.me/"/>
  <updated>2018-12-07T08:23:27.725Z</updated>
  <id>https://qinyuan97.me/</id>
  
  <author>
    <name>Yung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对象的创建和销毁</title>
    <link href="https://qinyuan97.me/2018/12/07/effectiveJava2/"/>
    <id>https://qinyuan97.me/2018/12/07/effectiveJava2/</id>
    <published>2018-12-07T08:22:45.251Z</published>
    <updated>2018-12-07T08:23:27.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。</p><a id="more"></a><h2 id="1-考虑用静态工厂方法替代构造函数"><a href="#1-考虑用静态工厂方法替代构造函数" class="headerlink" title="1. 考虑用静态工厂方法替代构造函数"></a><strong>1. 考虑用静态工厂方法替代构造函数</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(b ? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a><strong>好处</strong></h3><ul><li>与构造函数不同，静态工厂方法拥有名字，可以使一个类更易与使用，代码更易读</li><li>每次被调用时，不要求非得创建一个对象<br>把已经构造好的实例缓存起来，避免频繁创建相同的对象</li><li>可以返回一个原返回类型子类的对象</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul><li>如果类不含有公有的或受保护的构造函数，就不能被子类化</li><li>与其他的静态方法没有任何区别<br>在API文档中，不会像构造函数那样被明显标示出来。静态工作方法应遵守标准的命名规范，如 getInstance</li></ul><p><br></p><h2 id="2-使用私有构造函数强化singleton属性"><a href="#2-使用私有构造函数强化singleton属性" class="headerlink" title="2. 使用私有构造函数强化singleton属性"></a><strong>2. 使用私有构造函数强化singleton属性</strong></h2><p>&emsp;&emsp;singleton通常被用来指代那些本质上具有唯一性的系统组件，比如系统显示或文件系统。<br>&emsp;&emsp;实现单例有两种方法，都要把构造函数保持为私有的，并且提供一个静态成员，以便允许客户能访问到该类唯一的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种提供了一个公有的静态方法，而不是公有的静态final域。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当序列化遇到单例时,就会出现问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求一个JVM中只有一个类对象的, 而现在通过反序列化,一个新的对象克隆了出来。<br>加入readResolve方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尽管构造函数是私有的，但可序列化工具具有创建类实例的特殊访问权限—— 被实例化的类上的私有方法，称为readResolve（）。</p><p><br></p><h2 id="3-私有化构造函数使类不能实例化"><a href="#3-私有化构造函数使类不能实例化" class="headerlink" title="3. 私有化构造函数使类不能实例化"></a><strong>3. 私有化构造函数使类不能实例化</strong></h2><p>这样的工具类(utility class)不希望被实例化，让其包含单个显式的私有构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">utilityClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> utilityClass&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="4-避免创建重复的对象"><a href="#4-避免创建重复的对象" class="headerlink" title="4. 避免创建重复的对象"></a><strong>4. 避免创建重复的对象</strong></h2><p>反面例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"silly"</span>); <span class="comment">// DOn't DO THIS!</span></span><br></pre></td></tr></table></figure></p><p>应当：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"no longer silly"</span>;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="5-消除过期的对象引用"><a href="#5-消除过期的对象引用" class="headerlink" title="5. 消除过期的对象引用"></a><strong>5. 消除过期的对象引用</strong></h2><p>一个可能引起内存泄漏的例子（用数组实现栈）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 确保容量</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size)&#123;</span><br><span class="line">            Object[] oldElements = elements;</span><br><span class="line">            elements = <span class="keyword">new</span> Object[<span class="number">2</span> * size + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(oldElements, <span class="number">0</span>, elements, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题：如果一个栈先增长，再弹出，那么弹出的对象不会被当做垃圾回收。</p><p>修复：一旦对象引用已经过期，将其置空。pop()方法修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">    Object result = element[--size];</span><br><span class="line">    element[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="6-避免使用终结函数-finalize"><a href="#6-避免使用终结函数-finalize" class="headerlink" title="6. 避免使用终结函数(finalize)"></a><strong>6. 避免使用终结函数(finalize)</strong></h2><p>如果一个子类改写了终结函数，那么子类的终结函数必须手工调用超类的终结函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.finalize();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本章主题是创建和销毁对象：什么时候、如何创建对象；什么时候、如何避免创建对象；如何保证对象能够适时的销毁；对象被销毁前如何管理各种清理工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://qinyuan97.me/categories/Java/"/>
    
    
      <category term="EffectiveJava" scheme="https://qinyuan97.me/tags/EffectiveJava/"/>
    
      <category term="Object" scheme="https://qinyuan97.me/tags/Object/"/>
    
  </entry>
  
</feed>
